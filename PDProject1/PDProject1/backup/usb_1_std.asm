;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB_1_std.asm
;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
;;  Generated by PSoC Designer 5.4.3191
;;
;;  DESCRIPTION: USB Device User Module software implementation file
;;
;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API
;;        function returns. Even though these registers may be preserved now,
;;        there is no guarantee they will be preserved in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "USB_1_macros.inc"
include "USB_1.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------

AREA bss (RAM,REL)

;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------
;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------

AREA UserModules (ROM, REL)

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_Not_Supported
;
;  DESCRIPTION:   The USB_1_Not_Supported routine is invoked for any
;         USB request that is not supported.  It is invoked with a
;         JMP/LJMP and does not return.  It exits through the common
;                 EP0 exit.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     None
;
;  RETURNS:       Does not return
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

; d2h_std_dev
IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_00
USB_1_CB_d2h_std_dev_00:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_01
USB_1_CB_d2h_std_dev_01:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_02
USB_1_CB_d2h_std_dev_02:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_03
USB_1_CB_d2h_std_dev_03:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_04
USB_1_CB_d2h_std_dev_04:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_05
USB_1_CB_d2h_std_dev_05:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_06
USB_1_CB_d2h_std_dev_06:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_07
USB_1_CB_d2h_std_dev_07:
ENDIF
IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_dev_08
USB_1_CB_d2h_std_dev_08:
ENDIF

; h2d_std_dev
IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_00
USB_1_CB_h2d_std_dev_00:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_01
USB_1_CB_h2d_std_dev_01:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_02
USB_1_CB_h2d_std_dev_02:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_03
USB_1_CB_h2d_std_dev_03:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_04
USB_1_CB_h2d_std_dev_04:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_05
USB_1_CB_h2d_std_dev_05:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_06
USB_1_CB_h2d_std_dev_06:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_07
USB_1_CB_h2d_std_dev_07:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_08
USB_1_CB_h2d_std_dev_08:
ENDIF
IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_dev_09
USB_1_CB_h2d_std_dev_09:
ENDIF

; d2h_std_ifc
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_00
USB_1_CB_d2h_std_ifc_00:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_01
USB_1_CB_d2h_std_ifc_01:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_02
USB_1_CB_d2h_std_ifc_02:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_03
USB_1_CB_d2h_std_ifc_03:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_04
USB_1_CB_d2h_std_ifc_04:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_05
USB_1_CB_d2h_std_ifc_05:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_06
USB_1_CB_d2h_std_ifc_06:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_07
USB_1_CB_d2h_std_ifc_07:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_08
USB_1_CB_d2h_std_ifc_08:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_09
USB_1_CB_d2h_std_ifc_09:
ENDIF
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ifc_10
USB_1_CB_d2h_std_ifc_10:
ENDIF

; d2h_std_ifc
IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_ifc_00
USB_1_CB_h2d_std_ifc_00:
ENDIF

; d2h_std_ep
IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_d2h_std_ep_00
USB_1_CB_d2h_std_ep_00:
ENDIF

; h2d_std_ep
IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_ep_00
USB_1_CB_h2d_std_ep_00:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_ep_01
USB_1_CB_h2d_std_ep_01:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_ep_02
USB_1_CB_h2d_std_ep_02:
ENDIF
IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
export  USB_1_CB_h2d_std_ep_03
USB_1_CB_h2d_std_ep_03:
ENDIF

export  USB_1_Not_Supported
export _USB_1_Not_Supported
USB_1_Not_Supported:
_USB_1_Not_Supported:
   MOV    A, 0                         ; Count 0
   MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
   LJMP   USB_1_EP0_UPD_MODE_EXIT
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_d2h_std_dev_00
;
;  DESCRIPTION:   Get Device Status
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h     
; bRequest       : GET_STATUS                     = 00h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
; 
; The GET_DEVICE_STATUS request returns the current device status.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.LITERAL
GetStatusTransferDescrTable:
    TD_START_TABLE 1                   ; One entry
    TD_ENTRY    USB_DS_RAM, 2, USB_1_TransferBuffer, NULL_PTR  ; Intermediate Buffer
.ENDLITERAL
IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
export  USB_1_CB_d2h_std_dev_00
USB_1_CB_d2h_std_dev_00:
    MOV     [USB_1_t2], 0              ; Use the UM temp var--Selector

    MOV     [USB_1_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
    MOV     [USB_1_TransferBuffer], [USB_1_DeviceStatus]

    MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
    MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
    JMP     USB_1_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_dev_00
USB_1_CB_d2h_std_dev_00:
    LJMP    APP_USB_1_CB_d2h_std_dev_00
ENDIF
ENDIF
;-----------------------------------------------------------------------------
; FUNCTION NAME: USB_1_CB_d2h_std_dev_06
;
; DESCRIPTION:   Get Device Descriptor
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_DESCRIPTOR                 = 06h    
; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh  
; wIndex         : ZERO or LANG_ID                = xxxxh
; wLength        : SIZEOF_DESCRIPTOR              = --xxh  
; 
; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if 
; the descriptor exists. 
; 
; The upper byte of wValue contains the descriptor type and 
; the lower byte contains the descriptor index. wIndex 
; contains either 0000h or the Language ID. wLength contains 
; the descriptor length. The actual descriptor information is 
; transferred in subsequent data packets. 
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
export  USB_1_CB_d2h_std_dev_06
USB_1_CB_d2h_std_dev_06:
;-----------------------------------------------------------------------------
; Dispatch to the proper handler
;-----------------------------------------------------------------------------
    MOV     A, REG[USB_1_EP0DATA+wValueHi] ; Get the descrptor type
    ASL     A                          ; Make it into a offset
    CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
    JNC     USB_1_Not_Supported

    JACC    GET_DESCR_DISPATCH

GET_DESCR_DISPATCH:
    JMP     USB_1_Not_Supported        ; Invalid
    JMP     USB_1_SendDeviceDescr      ; Device Descriptor
    JMP     USB_1_SendConfigDescr      ; Configuration Descriptor
IF  USB_1_bNumStringDescrs             ; Number of String Descriptor defined with the Wizard
    JMP     USB_1_SendStringDescr      ; String Descriptor
ELSE
    JMP     USB_1_Not_Supported        ; Not supported if we don't have
                                            ; any String Descriptor
ENDIF
GET_DESCR_DISPATCH_END:
GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)     
;-----------------------------------------------------------------------------
; Configuration Descriptor Handler
;-----------------------------------------------------------------------------
USB_1_SendConfigDescr:
    CALL    USB_1_GET_DEVICE_TABLE_ENTRY
    SWAP    A, X
    ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
    SWAP    A, X
    ADC     A, 0                       ; Don't forget the carry
    MOV    [USB_1_t2], USB_1_t1        ; Set up the destination  
    CALL    USB_1_GETWORD              ; Get the pointer
    
    MOV     A, [USB_1_t1]              ; Pointer MSB
    MOV     X, [USB_1_t1+1]            ; Pointer LSB
    
    PUSH    A                          ; Save the MSB
    
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the descrptor index
    MOV     [USB_1_t2], A              ; Use the UM temp var--Selector
    POP     A                          ; Need the MSB for the range check
    PUSH    A                          ; Save the MSB for after the range check
    ROMX                               ; First entry is the table size (only a byte)
    CMP     A, [USB_1_t2]              ; Range check
    JNC     .range_ok
    
    POP     A                          ; Fix the stack
    JMP    USB_1_Not_Supported

.range_ok:
    POP     A                          ; Get the MSB back
    JMP     USB_1_GetTableEntry_Local_Std
;-----------------------------------------------------------------------------
; Device Descriptor Handler
;-----------------------------------------------------------------------------
USB_1_SendDeviceDescr:
    MOV     [USB_1_t2], [USB_1_bCurrentDevice]  ; Use the UM temp var--Selector
    MOV     A,>USB_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
    MOV     X,<USB_1_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
    ROMX                               ; First entry is the table size (only a byte)
    CMP     A, [USB_1_t2]              ; Range check
    JC      USB_1_Not_Supported

    MOV     A,>USB_1_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB

    JMP     USB_1_GetTableEntry_Local_Std
;-----------------------------------------------------------------------------
; String Descriptor Handler
;-----------------------------------------------------------------------------
IF  USB_1_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
USB_1_SendStringDescr:
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the descrptor index
    MOV     [USB_1_t2], A              ; Use the UM temp var--Selector

    MOV     A,>USB_1_StringTable       ; Get the ROM Address MSB
    MOV     X,<USB_1_StringTable       ; Get the ROM Address LSB
    ROMX                               ; First entry is the table size (only a byte)
    CMP     A, [USB_1_t2]              ; Range check
    JC      USB_1_Not_Supported

    MOV     A,>USB_1_StringTable       ; Get the ROM Address MSB

    JMP     USB_1_GetTableEntry_Local_Std
ENDIF
ELSE
IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_dev_06
USB_1_CB_d2h_std_dev_06:
    LJMP    APP_USB_1_CB_d2h_std_dev_06
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_d2h_std_dev_08
;
;  DESCRIPTION:   Get Device Configuration
;
;****************************************************************
; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
; bRequest       : GET_CONFIGURATION              = 08h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : RESERVED                       = 0000h
; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h  
; 
; The GET_DEVICE_CONFIGURATION request returns the currently 
; selected device configuration number. 
;
; request_value and request_index contain 0000h. request_length 
; contains 0001h and the one-byte configuration number is returned 
; in a separate data transfer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
.LITERAL
GetConfigTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY    USB_DS_RAM, 1, USB_1_Configuration, NULL_PTR  ; Current configuration
.ENDLITERAL
export  USB_1_CB_d2h_std_dev_08
USB_1_CB_d2h_std_dev_08:
    MOV     [USB_1_t2], 0              ; Use the UM temp var--Selector
    MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
    MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
    JMP     USB_1_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_dev_08
USB_1_CB_d2h_std_dev_08:
    LJMP    APP_USB_1_CB_d2h_std_dev_08
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_dev_01
;
;  DESCRIPTION:   Clear Device Feature
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : CLEAR_FEATURE                  = 01h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The CLEAR_DEVICE_FEATURE request disables a particular feature 
; for a device. The only feature supported for a device is the 
; REMOTE_WAKEUP feature.
; 
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_dev_01
USB_1_CB_h2d_std_dev_01:
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
    JNZ     USB_1_Not_Supported        ;      
    AND     [USB_1_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_dev_01
USB_1_CB_h2d_std_dev_01:
    LJMP    APP_USB_1_CB_h2d_std_dev_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_dev_03
;
;  DESCRIPTION:   Set Device Featue
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_FEATURE                    = 03h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_FEATURE request enables a particular feature
; on a device. The only feature supported for a device is the 
; REMOTE_WAKEUP feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_dev_03
USB_1_CB_h2d_std_dev_03:
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the Feature Selector
                                       ; Check against valid features
                                       ;  for device receipient
    CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
    JZ      .remote_wakeup

    CMP     A, USB_TEST_MODE           ; Test Mode 
    JZ      .test_mode
; Flow here for any other selector is invalid for device receipient
    JMP     USB_1_Not_Supported
; Jump here to enable remote wake up
.remote_wakeup:
    OR      [USB_1_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
    JMP     .finish
; Jump here to enable test mode
.test_mode:
    JMP     USB_1_Not_Supported
.finish:
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_dev_03
USB_1_CB_h2d_std_dev_03:
    LJMP    APP_USB_1_CB_h2d_std_dev_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_dev_05
;
;  DESCRIPTION:   Set Device Address
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Address
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_ADDRESS                    = 05h    
; wValue         : DEVICE_ADDRESS                 = 00xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_ADDRESS request sets the USB device address
; for all future USB accesses. 
;
;****************************************************************
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_dev_05
USB_1_CB_h2d_std_dev_05:
      
    MOV     [USB_1_fDataPending], USB_ADDRESS_CHANGE_PENDING       
    MOV     A, REG[USB_1_EP0DATA+wValueLo]       
    MOV     [USB_1_TransferBuffer],A       
                                                   
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_dev_05
USB_1_CB_h2d_std_dev_05:
    LJMP    APP_USB_1_CB_h2d_std_dev_05
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_dev_09
;
;  DESCRIPTION:   Set Configuration
;
;****************************************************************
; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
; bRequest       : SET_CONFIGURATION              = 09h    
; wValue         : CONFIGURATION_VALUE            = --xxh  
; wIndex         : RESERVED                       = 0000h
; wLength        : RESERVED                       = 0000h  
; 
; The SET_DEVICE_CONFIGURATION request selects a device 
; configuration to be activated as the current configuration. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_dev_09
USB_1_CB_h2d_std_dev_09:
    CALL    USB_1_GET_DEVICE_TABLE_ENTRY  ; Get the selected device
    MOV     [USB_1_t2],USB_1_t1        ; Set the GETWORD destination 
    CALL    USB_1_GETWORD              ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the configuration number
    MOV     [USB_1_t2],A               ; Save it 
    MOV     A, [USB_1_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    MOV     X, [USB_1_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    ROMX                               ; First entry is the table size (only a byte)
    CMP     A, [USB_1_t2]              ; Range check
    JC      USB_1_Not_Supported

; Refactored from the two loops below
    MOV     [USB_1_Configuration],[USB_1_t2]  ; Save the config number

    CMP     [USB_1_t2], 0              ; Unconfigure?
    JZ      .unconfigure

; Flow here to configure the endpoints
    MOV     A, [USB_1_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    MOV     X, [USB_1_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    INC     X                          ; Point to the first table entry
    ADC     A, 0                       ;
    MOV    [USB_1_t2], USB_1_t1        ; Set up the destination  
    CALL    USB_1_GETWORD              ; Get the pointer to the CONFIG_LOOKUP table
                                       ; ITempW has the address
    MOV     X, 0                       ; Start the index at 0, but we INC first
.configure_next:
    INC     X                          ; Do the next one
    PUSH    X                          ; Save the endpoint number
    MOV     A, [USB_1_t1]              ; Get the CONFIG_LOOKUP ROM Address MSB
    MOV     X, [USB_1_t1+1]            ; Get the CONFIG_LOOKUP ROM Address LSB
    ROMX
    INC     [USB_1_t1+1]               ; Point to the next 
    ADC     [USB_1_t1], 0              ;
    POP     X
    CALL    ConfigureEP                ; X contains the EP number
                                       ; A contains the EP Direction
    MOV     A, X                       ; 
    CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
    JNZ     .configure_next            ; Do another one?
; Flow here when we are done
    JMP     .done

; Jump here to unconfigure the endpoints
.unconfigure:
    MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
.unconfigure_next:
    MOV     [X+USB_1_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
    MOV     REG[X+EP0MODE], USB_MODE_DISABLE ; Disable the endpoint
    DEC     X                          ; One more down
    JNZ     .unconfigure_next          ; Don't unconfigure EP0
.done:
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_dev_09
USB_1_CB_h2d_std_dev_09:
    LJMP    APP_USB_1_CB_h2d_std_dev_09
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_d2h_std_ifc_00
;
;  DESCRIPTION:   Get Interface Status
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h    
; bRequest       : GET_STATUS                     = 00h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : INTERFACE                      = --xxh
; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h  
; 
; The GET_INTERFACE_STATUS request returns status for the 
; specified interface.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
.LITERAL
GetInterfaceStatusTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 2, USB_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
.ENDLITERAL
export  USB_1_CB_d2h_std_ifc_00
USB_1_CB_d2h_std_ifc_00:

    MOV     [USB_1_TransferBuffer], 0     ; Zero the transfer buffer
    MOV     [USB_1_TransferBuffer+1], 0  ; 

    MOV     [USB_1_t2], 0              ; Use the UM temp var--Selector
    MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
    MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB

    JMP     USB_1_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_ifc_00
USB_1_CB_d2h_std_ifc_00:
    LJMP    APP_USB_1_CB_d2h_std_ifc_00
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_d2h_std_ifc_10
;
;  DESCRIPTION:   Get Interface
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
; bRequest       : GET_INTERFACE                  = 0Ah    
; wValue         : RESERVED                       = 0000h  
; wIndex         : INTERFACE                      = xxxxh
; wLength        : SIZEOF_GET_INTERFACE           = 0001h  
; 
; The GET_INTERFACE request returns the selected alternate 
; setting for the specified interface. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------

IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
.LITERAL
GetInterfaceTransferDescrTable:
    TD_START_TABLE  1                  ; One entry
    TD_ENTRY        USB_DS_RAM, 1, USB_1_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
.ENDLITERAL
export  USB_1_CB_d2h_std_ifc_10
USB_1_CB_d2h_std_ifc_10:
    MOV     A, REG[USB_1_EP0DATA+wIndexLo]  ; Get the interface number
    CMP     A, 1h                      ; Valid interface number? (UM Parameter: NumInterfaces)
    JNC     USB_1_Not_Supported

    MOV     X, A                       ; The interface number is the index into alternates settings table

    MOV     A, [X + USB_1_InterfaceSetting]  ; Save the current interface setting
    MOV     [USB_1_TransferBuffer], A     ; into the transfer buffer

    MOV     [USB_1_t2], 0              ; Use the UM temp var--Selector
    MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
    MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB

    JMP     USB_1_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_ifc_10
USB_1_CB_d2h_std_ifc_10:
    LJMP    APP_USB_1_CB_d2h_std_ifc_10
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_d2h_std_ep_00
;
;  DESCRIPTION:   Get Endpoint Status
;
;****************************************************************
; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
;****************************************************************
;
; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h    
; bRequest       : GET_STATUS                     = 00h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
; 
; The GET_ENDPOINT_STATUS request returns status for the specified 
; endpoint.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
export  USB_1_CB_d2h_std_ep_00
USB_1_CB_d2h_std_ep_00:
    MOV     A, REG[USB_1_EP0DATA+wIndexLo]  ; Get the endpoint number
    AND     A, ~USB_DIR_IN             ; Strip off the direction bit
    CMP     A, USB_NUM_ENDPOINTS       ; Range check
    JNC     USB_1_Not_Supported

    MOV     X, A                       ; The endpoint number is the index

    MOV     [USB_1_t2], 0              ; Use the UM temp var--Selector

    MOV     [USB_1_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
    MOV     A, [X + USB_1_EndpointStatus]  ; Get the status
    MOV     [USB_1_TransferBuffer], A  ; Save it in the report

    MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
    MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB

    JMP     USB_1_GetTableEntry_Local_Std
ELSE
IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
export  USB_1_CB_d2h_std_ep_00
USB_1_CB_d2h_std_ep_00:
    LJMP    APP_USB_1_CB_d2h_std_ep_00
ENDIF
ENDIF

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_ep_01
;
;  DESCRIPTION:   Clear Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : CLEAR_FEATURE                  = 01h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h  
; 
; The CLEAR_ENDPOINT_FEATURE request disables a particular 
; feature for an endpoint. 
;
; The only feature supported for an endpoint is the EP_HALT 
; feature.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_ep_01
USB_1_CB_h2d_std_ep_01:
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the feature selector
    CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
    JNZ     USB_1_Not_Supported

    MOV     A, REG[USB_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
    AND     A, ~USB_DIR_IN             ; Strip off the direction bit
    CMP     A, 0                       ; Since we can't halt the Control Endpoint
    JZ      .done

    CMP     A, USB_NUM_ENDPOINTS       ; Range check
    JNC     USB_1_Not_Supported

    MOV     X, A                       ; Endpoint number is the index
    AND     [X+USB_1_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt

    TST     REG[USB_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
    JNZ     .in

    MOV     REG[X + USB_1_EP0MODE], USB_MODE_NAK_OUT  ; NAK the endpoint
    JMP     .done    
.in:
    MOV     REG[X + USB_1_EP0MODE], USB_MODE_NAK_IN  ; NAK the endpoint
.done:        
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_ep_01
USB_1_CB_h2d_std_ep_01:
    LJMP    APP_USB_1_CB_h2d_std_ep_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_1_CB_h2d_std_ep_03
;
;  DESCRIPTION:   Set Endpoint Feature
;
;****************************************************************
; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
;****************************************************************
;
; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
; bRequest       : SET_FEATURE                    = 03h    
; wValue         : FEATURE_SELECTOR               = --xxh  
; wIndex         : ENDPOINT                       = 00xxh
; wLength        : RESERVED                       = 0000h  
; 
; The SET_ENDPOINT_FEATURE request enables a particular feature
; for a specific endpoint. The only feature supported for an 
; endpoint is the EP_HALT feature.
; 
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
export  USB_1_CB_h2d_std_ep_03
USB_1_CB_h2d_std_ep_03:
    MOV     A, REG[USB_1_EP0DATA+wValueLo]  ; Get the feature selector
    CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
    JNZ     USB_1_Not_Supported

    MOV     A, REG[USB_1_EP0DATA+wIndexLo]  ; Get the Endpoint number
    AND     A, ~USB_DIR_IN             ; Strip off the direction bit
    CMP     A, 0                       ; Never halt the Control Endpoint
    JZ      .done

    CMP     A, USB_NUM_ENDPOINTS       ; Range check
    JNC     USB_1_Not_Supported

    MOV     X, A                       ; Endpoint number is the index

    OR      [X+USB_1_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint

    TST     REG[USB_1_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
    JNZ     .in

    MOV     REG[X + USB_1_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
    JMP     .done    
.in:
    MOV     REG[X + USB_1_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
.done:        
    JMP     USB_1_NoDataStageControlTransfer_Local_Std
ELSE
IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
export  USB_1_CB_h2d_std_ep_03
USB_1_CB_h2d_std_ep_03:
    LJMP    APP_USB_1_CB_h2d_std_ep_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ConfigureEP
;
;  DESCRIPTION:   Configure an endpoint
;
;  ARGUMENTS:    A contains the endpoint direction
;                X contains the endpoint number
;
;  RETURNS:
;
;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
ConfigureEP:
    CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
    JNZ     .enable                    ; Only enable it if it is used
    RET                                ; Quick exit if this endpoint is unused

; Jump here to enable an endpoint
.enable:
    PUSH    A                          ; Save the endpoint direction
    MOV     A, X                       ; We are using a JACC to dispatch to enable the interrupt
    ASL     A                          ;  
    JACC    .EP_INT_ENABLE             ;  
.EP_INT_ENABLE:
    JMP     .EP0IntEnable              ; Enable EP0
    JMP     .EP1IntEnable              ; Enable EP1
    JMP     .EP2IntEnable              ; Enable EP2
; Jump here to enable EP0 Interrupts
.EP0IntEnable:
    M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP0
    JMP     .cont
.EP1IntEnable:
    M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP1
    JMP     .cont
.EP2IntEnable:
    M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP2
; Jump or flow here to continue configuring the endpoint    
.cont:

    MOV     A, X
    INDEX   USB_1_USB_EP_BIT_LOOKUP
    XOR     A, FFh
    AND     [USB_1_EPDataToggle], A ; Clear the data toggle

    POP     A                          ; Get the endpoint direction back
    AND     A, USB_DIR_IN              ; Is it an IN endpoint?
    JNZ     .in                        ; Jump on IN
; Flow here for an OUT Endpoint
    MOV     REG[X+EP0MODE], USB_MODE_NAK_OUT ; NAK the endpoint
    MOV     [X+USB_1_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
    RET
; Jump here for an IN Endpoint
.in:
    MOV     REG[X+EP0MODE], USB_MODE_NAK_IN ; NAK the endpoint
    MOV     [X+USB_1_EndpointAPIStatus], EVENT_PENDING ; For the API
    RET
;-----------------------------------------------------------------------------
;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
;
;  DESCRIPTION:   The following tables dispatch to the Standard request handler
;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
USB_1_DT_d2h_std_dev:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_d2h_std_dev_00
    jmp     USB_1_CB_d2h_std_dev_01
    jmp     USB_1_CB_d2h_std_dev_02
    jmp     USB_1_CB_d2h_std_dev_03
    jmp     USB_1_CB_d2h_std_dev_04
    jmp     USB_1_CB_d2h_std_dev_05
    jmp     USB_1_CB_d2h_std_dev_06
    jmp     USB_1_CB_d2h_std_dev_07
    jmp     USB_1_CB_d2h_std_dev_08

USB_1_DT_d2h_std_dev_End:
USB_1_DT_d2h_std_dev_Size: equ (USB_1_DT_d2h_std_dev_End-USB_1_DT_d2h_std_dev) / 2
USB_1_DT_d2h_std_dev_Dispatch::
    MOV    A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_d2h_std_dev, USB_1_DT_d2h_std_dev_Size, USB_1_Not_Supported 
;-----------------------------------------------------------------------------
USB_1_DT_h2d_std_dev:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_h2d_std_dev_00
    jmp     USB_1_CB_h2d_std_dev_01
    jmp     USB_1_CB_h2d_std_dev_02
    jmp     USB_1_CB_h2d_std_dev_03
    jmp     USB_1_CB_h2d_std_dev_04
    jmp     USB_1_CB_h2d_std_dev_05
    jmp     USB_1_CB_h2d_std_dev_06
    jmp     USB_1_CB_h2d_std_dev_07
    jmp     USB_1_CB_h2d_std_dev_08
    jmp     USB_1_CB_h2d_std_dev_09

USB_1_DT_h2d_std_dev_End:
USB_1_DT_h2d_std_dev_Size: equ (USB_1_DT_h2d_std_dev_End-USB_1_DT_h2d_std_dev) / 2
USB_1_DT_h2d_std_dev_Dispatch::

    MOV     A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_h2d_std_dev, USB_1_DT_h2d_std_dev_Size, USB_1_Not_Supported 

;-----------------------------------------------------------------------------
USB_1_DT_d2h_std_ifc:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_d2h_std_ifc_00
    jmp     USB_1_CB_d2h_std_ifc_01
    jmp     USB_1_CB_d2h_std_ifc_02
    jmp     USB_1_CB_d2h_std_ifc_03
    jmp     USB_1_CB_d2h_std_ifc_04
    jmp     USB_1_CB_d2h_std_ifc_05
    jmp     USB_1_CB_d2h_std_ifc_06
    jmp     USB_1_CB_d2h_std_ifc_07
    jmp     USB_1_CB_d2h_std_ifc_08
    jmp     USB_1_CB_d2h_std_ifc_09
    jmp     USB_1_CB_d2h_std_ifc_10
USB_1_DT_d2h_std_ifc_End:
USB_1_DT_d2h_std_ifc_Size: equ (USB_1_DT_d2h_std_ifc_End-USB_1_DT_d2h_std_ifc) / 2
USB_1_DT_d2h_std_ifc_Dispatch::
    CMP     [USB_1_Configuration], 0   ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP    _USB_1_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    MOV     A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_d2h_std_ifc, USB_1_DT_d2h_std_ifc_Size, USB_1_Not_Supported 

;-----------------------------------------------------------------------------
USB_1_DT_h2d_std_ifc:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_h2d_std_ifc_00

USB_1_DT_h2d_std_ifc_End:
USB_1_DT_h2d_std_ifc_Size: equ (USB_1_DT_h2d_std_ifc_End-USB_1_DT_h2d_std_ifc) / 2
USB_1_DT_h2d_std_ifc_Dispatch::
    CMP     [USB_1_Configuration], 0   ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP    _USB_1_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    MOV     A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_h2d_std_ifc, USB_1_DT_h2d_std_ifc_Size, USB_1_Not_Supported 

;-----------------------------------------------------------------------------
USB_1_DT_d2h_std_ep:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_d2h_std_ep_00

USB_1_DT_d2h_std_ep_End:
USB_1_DT_d2h_std_ep_Size: equ (USB_1_DT_d2h_std_ep_End-USB_1_DT_d2h_std_ep) / 2
USB_1_DT_d2h_std_ep_Dispatch::
    CMP     [USB_1_Configuration], 0   ; Is the device configured?
    JNZ     .configured                ; Jump on configured

    MOV     A, REG[USB_1_EP0DATA + wIndexHi] ; Is the request for EP0?
    MOV     [USB_1_t2], A              ; Use the UM temp var--Selector
    MOV     A, REG[USB_1_EP0DATA + wIndexLo] ;
    OR      [USB_1_t2], A              ; Use the UM temp var--Selector
    JZ      .ep0_request

    JMP    _USB_1_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    MOV     A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_d2h_std_ep, USB_1_DT_d2h_std_ep_Size, USB_1_Not_Supported 

;-----------------------------------------------------------------------------
USB_1_DT_h2d_std_ep:
;-----------------------------------------------------------------------------
    jmp     USB_1_CB_h2d_std_ep_00
    jmp     USB_1_CB_h2d_std_ep_01
    jmp     USB_1_CB_h2d_std_ep_02
    jmp     USB_1_CB_h2d_std_ep_03

USB_1_DT_h2d_std_ep_End:
USB_1_DT_h2d_std_ep_Size: equ (USB_1_DT_h2d_std_ep_End-USB_1_DT_h2d_std_ep) / 2
USB_1_DT_h2d_std_ep_Dispatch::
    CMP     [USB_1_Configuration], 0   ; Is the device configured?
    JNZ     .configured                ; Jump on configured

    MOV     A, REG[USB_1_EP0DATA + wIndexHi] ; Is the request for EP0?
    MOV     [USB_1_t2], A              ; Use the UM temp var--Selector
    MOV     A, REG[USB_1_EP0DATA + wIndexLo] ;
    OR      [USB_1_t2], A              ; Use the UM temp var--Selector
    JZ      .ep0_request

    JMP    _USB_1_Not_Supported        ; Stall the request if not configured
; Jump here if the device is configured or EP0 request
.configured:
.ep0_request:
    MOV     A, REG[USB_1_EP0DATA + bRequest]
    DISPATCHER USB_1_DT_h2d_std_ep, USB_1_DT_h2d_std_ep_Size, USB_1_Not_Supported 

USB_1_GetTableEntry_Local_Std:
    LJMP    USB_1_GetTableEntry

USB_1_NoDataStageControlTransfer_Local_Std:
    LJMP    USB_1_NoDataStageControlTransfer

;-----------------------------------------------
; Add custom application code for routines 
; redefined by USB_APP_SUPPLIED in USB_HID.INC
;-----------------------------------------------

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

; End of File USB_1_std.asm
