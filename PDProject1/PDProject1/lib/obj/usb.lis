 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           ;;  FILENAME: USB.asm
 0000           ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
 0000           ;;  Generated by PSoC Designer 5.4.3191
 0000           ;;
 0000           ;;  DESCRIPTION: USB Device User Module software implementation file
 0000           ;;
 0000           ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
 0000           ;;        arguments and observe the associated "Registers are volatile" policy.
 0000           ;;        This means it is the caller's responsibility to preserve any values
 0000           ;;        in the X and A registers that are still needed after the API
 0000           ;;        function returns. Even though these registers may be preserved now,
 0000           ;;        there is no guarantee they will be preserved in future releases.
 0000           ;;-----------------------------------------------------------------------------
 0000           ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           
 0010           FLAG_XIO_MASK:  equ 10h
 0008           FLAG_SUPER:     equ 08h
 0004           FLAG_CARRY:     equ 04h
 0002           FLAG_ZERO:      equ 02h
 0001           FLAG_GLOBAL_IE: equ 01h
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 0
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;------------------------------------------------
 0000           ; Port Data Registers
 0000           P0DATA:       equ 00h          ; Port 0 Data Register                     (RW)
 0001           P1DATA:       equ 01h          ; Port 1 Data Register                     (RW)
 0002           P2DATA:       equ 02h          ; Port 2 Data Register                     (RW)
 0003           P3DATA:       equ 03h          ; Port 3 Data Register                     (RW)
 0004           P4DATA:       equ 04h          ; Port 4 Data Register                     (RW)
 0000           ; PSoC Compatability
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)(PSoC)
 0001           PRT1DR:       equ 01h          ; Port 1 Data Register                     (RW)(PSoC)
 0002           PRT2DR:       equ 02h          ; Port 2 Data Register                     (RW)(PSoC)
 0003           PRT3DR:       equ 03h          ; Port 3 Data Register                     (RW)(PSoC)
 0004           PRT4DR:       equ 04h          ; Port 4 Data Register                     (RW)(PSoC)
 0000           
 0000           ; Port/Pin Configuration Registers
 0005           P00CR:        equ 05h          ; P0.0 Configuration Register              (RW)
 0006           P01CR:        equ 06h          ; P0.1 Configuration Register              (RW)
 0007           P02CR:        equ 07h          ; P0.2 Configuration Register              (RW)
 0008           P03CR:        equ 08h          ; P0.3 Configuration Register              (RW)
 0009           P04CR:        equ 09h          ; P0.4 Configuration Register              (RW)
 000A           P05CR:        equ 0Ah          ; P0.5 Configuration Register              (RW)
 000B           P06CR:        equ 0Bh          ; P0.6 Configuration Register              (RW)
 000C           P07CR:        equ 0Ch          ; P0.7 Configuration Register              (RW)
 000D           P10CR:        equ 0Dh          ; P1.0 Configuration Register              (RW)
 000E           P11CR:        equ 0Eh          ; P1.1 Configuration Register              (RW)
 000F           P12CR:        equ 0Fh          ; P1.2 Configuration Register              (RW)
 0010           P13CR:        equ 10h          ; P1.3 Configuration Register              (RW)
 0011           P14CR:        equ 11h          ; P1.4 Configuration Register              (RW)
 0012           P15CR:        equ 12h          ; P1.5 Configuration Register              (RW)
 0013           P16CR:        equ 13h          ; P1.6 Configuration Register              (RW)
 0014           P17CR:        equ 14h          ; P1.7 Configuration Register              (RW)
 0015           P2CR:         equ 15h          ; P2.0-P2.7 Configuration Register         (RW)
 0016           P3CR:         equ 16h          ; P3.0-P3.7 Configuration Register         (RW)
 0017           P4CR:         equ 17h          ; P4.0-P4.7 Configuration Register         (RW)
 0000           
 0000           ; Timer Registers
 0020           FRTMRL:       equ 20h          ; Free Running Timer Low                   (RW)
 0021           FRTMRH:       equ 21h          ; Free Running Timer High                  (RW)
 0022           TCAP0R:       equ 22h          ; Capture 0 Rising                         (R)             
 0023           TCAP1R:       equ 23h          ; Capture 1 Rising                         (R)             
 0024           TCAP0F:       equ 24h          ; Capture 0 Falling                        (R)             
 0025           TCAP1F:       equ 25h          ; Capture 1 Falling                        (R)             
 0026           PITMRL:       equ 26h          ; Programmable Interval Timer Low          (RW)
 0027           PITMRH:       equ 27h          ; Programmable Interval Timer High         (RW)
 0028           PIRL:         equ 28h          ; Programmable Interval Timer Reload Low   (RW)
 0029           PIRH:         equ 29h          ; Programmable Interval Timer Reload High  (RW)
 002A           TMRCR:        equ 2Ah          ; Timer Configuration Register             (RW)
 002B           TCAPINTE:     equ 2Bh          ; Capture Timer Interrupt Enable           (RW)
 002C           TCAPINTS:     equ 2Ch          ; Capture Timer Interrupt Status           (RW)
 0000           
 0000           ; Clock Configuration Registers
 0030           CPUCLKCR:     equ 30h          ; CPU Clock Configuration Register         (RW)
 0000           CPUCLK_SEL_INT:         equ 00h ; CPU Clock Select Internal Oscillator
 0001           CPUCLK_SEL_EXT:         equ 01h ; CPU Clock Select External Clock
 0000           CPUCLK_USBCLK_SEL_INT:  equ 00h ; USB Clock Select Internal Clock
 0040           CPUCLK_USBCLK_SEL_EXT:  equ 40h ; USB Clock Select External Clock
 0000           CPUCLK_USBCLK_DIV2_DIS: equ 00h ; USB Clock Divide by 2 disable
 0080           CPUCLK_USBCLK_DIV2_ENA: equ 80h ; USB Clock Divide by 2 enable
 0000           
 0031           TMRCLKCR:     equ 31h          ; Timer Clock Configuration Register       (RW)
 0000           TMRCLKCR_ITMRCLK_IOSC:     equ 00h ; MASK: ITMRCLK Source--Internal Oscillator
 0001           TMRCLKCR_ITMRCLK_XOSC:     equ 01h ; MASK: ITMRCLK Source--External Oscillator or CLKIN
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0003           TMRCLKCR_ITMRCLK_TCAPCLK:  equ 03h ; MASK: ITMRCLK Source--TCAPCLK
 0000           TMRCLKCR_ITMRCLK_DIV_1:    equ 00h ; MASK: ITMRCLK Divider Value 1
 0004           TMRCLKCR_ITMRCLK_DIV_2:    equ 04h ; MASK: ITMRCLK Divider Value 2
 0008           TMRCLKCR_ITMRCLK_DIV_3:    equ 08h ; MASK: ITMRCLK Divider Value 3
 000C           TMRCLKCR_ITMRCLK_DIV_4:    equ 0Ch ; MASK: ITMRCLK Divider Value 4
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0000           TMRCLKCR_TCAPCLK_IOSC:     equ 00h ; MASK: TCAPCLK Source--Internal Oscillator
 0010           TMRCLKCR_TCAPCLK_XOSC:     equ 10h ; MASK: TCAPCLK Source--External Oscillator or CLKIN
 0020           TMRCLKCR_TCAPCLK_LPO:      equ 20h ; MASK: TCAPCLK Source--Low Power Oscillator (32 Khz)
 0030           TMRCLKCR_TCAPCLK_DISABLED: equ 30h ; MASK: TCAPCLK Source--DISABLED
 0000           TMRCLKCR_TCAPCLK_DIV_2:    equ 00h ; MASK: TCAPCLK Divider Value 2
 0040           TMRCLKCR_TCAPCLK_DIV_4:    equ 40h ; MASK: TCAPCLK Divider Value 4
 0080           TMRCLKCR_TCAPCLK_DIV_6:    equ 80h ; MASK: TCAPCLK Divider Value 6
 00C0           TMRCLKCR_TCAPCLK_DIV_8:    equ 0C0h ; MASK: TCAPCLK Divider Value 8
 0000           
 0032           CLKIOCR:      equ 32h          ; Clock I/O Configuration Register         (RW)
 0000           CLKIOCR_CLKOUT_IOSC:       equ 00h ; MASK: Clock Source--Internal Oscillator
 0001           CLKIOCR_CLKOUT_XOSC:       equ 01h ; MASK: Clock Source--External Oscillator or CLKIN
 0002           CLKIOCR_CLKOUT_LPO:        equ 02h ; MASK: Clock Source--Low Power Oscillator (32 Khz)
 0003           CLKIOCR_CLKOUT_CPUCLK:     equ 03h ; MASK: Clock Source--CPUCLK
 0000           
 0000           ; Oscillator Configuration Registers
 0034           IOSCTR:       equ 34h          ; Internal Oscillator Trim Register        (R)
 0035           XOSCTR:       equ 35h          ; Crystal Oscillator Trim Register         (R)
 0036           LPOSCTR:      equ 36h          ; Low Power Oscillator Trim Register       (RW)
 0000           
 0000           ; SPI Configuration/Data Registers
 003C           SPIDATA:      equ 3Ch          ; SPI Data Register                        (RW)
 003D           SPICR:        equ 3Dh          ; SPI Configuration Register               (RW)
 0000           
 0000           ; USB SIE Configuration/Data Registers
 0040           USBCR:        equ 40h          ; USB Configuration Register               (RW)
 0041           EP0CNT:       equ 41h          ; Endpoint 0 Count Register                (RW)
 0042           EP1CNT:       equ 42h          ; Endpoint 1 Count Register                (RW)
 0043           EP2CNT:       equ 43h          ; Endpoint 2 Count Register                (RW)
 0044           EP0MODE:      equ 44h          ; Endpoint 0 Mode  Register                (RW)
 0045           EP1MODE:      equ 45h          ; Endpoint 1 Mode  Register                (RW)
 0046           EP2MODE:      equ 46h          ; Endpoint 2 Mode  Register                (RW)
 0050           EP0DATA:      equ 50h          ; Endpoint 0 Data  Register (50h-57h)      (RW)
 0058           EP1DATA:      equ 58h          ; Endpoint 1 Data  Register (58h-5Fh)      (RW)
 0060           EP2DATA:      equ 60h          ; Endpoint 2 Data  Register (60h-67h)      (RW)
 0000           
 0000           ; Band-gap/TRIMBUF Configuration Registers
 0070           BGAPTR:       equ 70h          ; Band-gap Trim Register                   (R)
 0071           TRIM0:        equ 71h          ; TRIMBUF Trim Register 0                  (R)
 0072           TRIM1:        equ 72h          ; TRIMBUF Trim Register 1                  (R)
 0000           
 0000           ; VREG Configuration Register
 0073           VREGCR:       equ 73h          ; VREG Configuration Register              (RW)
 0000           
 0000           ; USB Transceiver Configuration Registers
 0074           USBXCR:       equ 74h          ; USB Transceiver Configuration Register   (RW)
 0080           USBXCR_ENABLE:    equ 80h      ; USB Transceiver Enable
 0001           USBXCR_FORCE:     equ 01h      ; USB Transceiver Force
 0000           
 0000           ; Data Pointer Registers--Listed for compatability with other M8C based parts.
 00D0           CPPDR:        equ 0D0h          ; Current Page Pointer Data Register       (RW)
 00D4           DPRDR:        equ 0D4h          ; Data Page Read Register                  (RW)
 00D5           DPWDR:        equ 0D5h          ; Data Page Write Register                 (RW)
 0000           
 0000           ; Watchdog Timer Reset
 00E3           RESWDT:       equ 0E3h          ; Watchdog Timer Reset                     (W)
 00E3           RES_WDT:      equ 0E3h          ; WatchDog Timer Register                  (W) (PSoC)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;------------------------------------------------
 00DA           INT_CLR0:     equ 0DAh          ; Interrupt Clear Register 0               (RW)
 0000                                          ; Use INT_MSK0 bit field masks
 00DB           INT_CLR1:     equ 0DBh          ; Interrupt Clear Register 1               (RW)
 0000                                          ; Use INT_MSK1 bit field masks
 00DC           INT_CLR2:     equ 0DCh          ; Interrupt Clear Register 2               (RW)
 0000                                          ; Use INT_MSK2 bit field masks
 0000           
 00DE           INT_MSK3:     equ 0DEh          ; Interrupt Mask Register                  (RW)
 0080           INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
 0000           
 00DF           INT_MSK2:     equ 0DFh          ; Interrupt Mask Register                  (RW)
 0040           INT_MSK2_GPIO_PORT4:       equ 40h ; MASK: enable/disable GPIO Port 4 interrupt
 0020           INT_MSK2_GPIO_PORT3:       equ 20h ; MASK: enable/disable GPIO Port 3 interrupt
 0010           INT_MSK2_GPIO_PORT2:       equ 10h ; MASK: enable/disable GPIO Port 2 interrupt
 0008           INT_MSK2_PS2_DATA_LOW:     equ 08h ; MASK: enable/disable PS/2 Data Low
 0004           INT_MSK2_GPIO_INT2:        equ 04h ; MASK: enable/disable GPIO INT2 interrupt
 0002           INT_MSK2_CTR_16_WRAP:      equ 02h ; MASK: enable/disable 16 bit counter wrap
 0001           INT_MSK2_TCAP1:            equ 01h ; MASK: enable/disable Timer/Capture 0 interrupt
 0000           
 00E0           INT_MSK0:     equ 0E0h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK0_GPIO_PORT1:       equ 80h ; MASK: enable/disable GPIO Port 1 interrupt
 0040           INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO_INT1:        equ 20h ; MASK: enable/disable GPIO INT1 interrupt
 0010           INT_MSK0_GPIO_PORT0:       equ 10h ; MASK: enable/disable GPIO Port 0 interrupt
 0008           INT_MSK0_SPI_RX:           equ 08h ; MASK: enable/disable SPI Receive interrupt
 0004           INT_MSK0_SPI_TX:           equ 04h ; MASK: enable/disable SPI Transmit interrupt
 0002           INT_MSK0_GPIO_INT0:        equ 02h ; MASK: enable/disable GPIO INT0 interrupt
 0001           INT_MSK0_POR_LVD:          equ 01h ; MASK: enable/disable POR/LVD interrupt
 0000           
 00E1           INT_MSK1:     equ 0E1h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK1_TCAP0:            equ 80h ; MASK: enable/disable Timer/Capture 0 interrupt
 0040           INT_MSK1_PIT:              equ 40h ; MASK: enable/disable Progrmmable Interval Timer
 0020           INT_MSK1_MS_TIMER:         equ 20h ; MASK: enable/disable One Millisecond Timer interrupt
 0010           INT_MSK1_USB_ACTIVITY:     equ 10h ; MASK: enable/disable USB Bus Activity interrupt
 0008           INT_MSK1_USB_BUS_RESET:    equ 08h ; MASK: enable/disable USB Bus Reset interrupt
 0004           INT_MSK1_USB_EP2:          equ 04h ; MASK: enable/disable USB Endpoint 2 interrupt
 0002           INT_MSK1_USB_EP1:          equ 02h ; MASK: enable/disable USB Endpoint 1 interrupt
 0001           INT_MSK1_USB_EP0:          equ 01h ; MASK: enable/disable USB Endpoint 0 interrupt
 0000           
 00E2           INT_VC:       equ 0E2h          ; Interrupt vector register                (RC)
 0000           
 0000           ;------------------------------------------------------
 0000           ;        Register bank 1.
 0000           ;------------------------------------------------------
 00E0           OSC_CR0:                   equ 0E0h  ; System Oscillator Control Register 0     (RW)
 0020           OSC_CR0_NO_BUZZ:           equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
 0018           OSC_CR0_SLEEP:             equ 18h    ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_SLEEP_512Hz:       equ 00h    ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_SLEEP_64Hz:        equ 08h    ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_SLEEP_8Hz:         equ 10h    ;     Set sleep bits for 125ms period
 0018           OSC_CR0_SLEEP_1Hz:         equ 18h    ;     Set sleep bits for 1 sec period
 0000           
 0007           OSC_CR0_CPU:               equ 07h    ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:          equ 00h    ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:          equ 01h    ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:         equ 02h    ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:         equ 03h    ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:        equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:        equ 05h    ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz:      equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
 0000           
 0000           ;------------------------------------------------------
 0000           ;  Note: The following registers are mapped into both
 0000           ;        register bank 0 AND register bank 1.
 0000           ;------------------------------------------------------
 00F7           CPU_F:        equ 0F7h          ; CPU Flag Register Access                 (RO)
 0000                                              ; Use FLAG_ masks defined at top of file
 00FF           CPU_SCR:     equ 0FFh          ; CPU Status and Control Register          (#)
 0080           CPU_SCR_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
 0020           CPU_SCR_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
 0010           CPU_SCR_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
 0008           CPU_SCR_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
 0001           CPU_SCR_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 1
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Clock and System Control Registers
 0000           ;------------------------------------------------
 0000           
 0000           ;;=============================================================================
 0000           ;;      M8C System Macros
 0000           ;;  These macros should be used when their functions are needed.
 0000           ;;=============================================================================
 0000           
 0000           ;----------------------------------------------------
 0000           ;  Swapping Register Banks
 0000           ;----------------------------------------------------
 0000               macro M8C_SetBank0
 0000               and   F, ~FLAG_XIO_MASK
 0000               macro M8C_SetBank1
 0000               or    F, FLAG_XIO_MASK
 0000               macro M8C_EnableGInt
 0000               or    F, FLAG_GLOBAL_IE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FLAG_GLOBAL_IE
 0000               macro M8C_DisableIntMask
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000               macro M8C_EnableIntMask
 0000               or    reg[@0], @1               ; enable specified interrupt enable bit
 0000               macro M8C_ClearIntFlag
 0000               mov   reg[@0], ~@1              ; clear specified interrupt enable bit
 0000               macro M8C_EnableWatchDog
 0000               and   reg[CPU_SCR], ~CPU_SCR_PORS_MASK
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR], CPU_SCR_SLEEP_MASK
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then the CPU sleeps forever.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR], CPU_SCR_STOP_MASK
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore CPU to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro Suspend_CodeCompressor
 0000               or   F, 0
 0000               macro Resume_CodeCompressor
 0000               add  SP, 0
 0000           MACRO   GET_WORD
 0000               PUSH A                              ; Quickly get a RAM temp
 0000               PUSH A                              ; Save the source MSB
 0000               ROMX                                ; Get the first byte
 0000               PUSH X                              ; Save X
 0000               MOV  X,SP                           ; Get SP, to index to the temp 
 0000               MOV  [X - 3],A                      ; Save the first byte
 0000               POP  X                              ; Get back the source LSB
 0000               POP  A                              ; And the MSB
 0000               INC  X                              ; Point to the second byte
 0000               ADC  A, 0                           ; 
 0000               ROMX                                ; Get the second byte
 0000               MOV  X,A                            ; Save it in X
 0000               POP  A                              ; And the first byte in A
 0000           MACRO   NULL_PTR_CHECK
 0000               SWAP    A, X                        ; LSB non-zero?
 0000               JNZ     .ok                         ; Exit on non-zero
 0000               SWAP    A, X                        ; MSB zero
 0000               JZ      @0                          ; Jump to the null pointer handler
 0000               JMP     .exit
 0000           .ok:
 0000               SWAP    A, X                        ; Put them back
 0000           .exit:
 0000           NULL_PTR:   EQU 0                       ; Null pointer value
 0000           
 0000           ;--------------------------------------------------
 0000           ; TRANSFER DESCRIPTOR MACROS
 0000           ;--------------------------------------------------
 0000           
 0000           ;-----------------------------------------------
 0000           ; TD_START_TABLE MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = Number of table entries
 0000           ; Register setup
 0000           ;   N/A (builds ROM data at assembly time)
 0000           ;-----------------------------------------------
 0000           MACRO   TD_START_TABLE
 0000               DB      ((@0) - 1)                 ; Number of table entries - 1
 0000           MACRO   TD_ENTRY
 0000               DB  @0                             ; Data source (USB_DS_*)
 0000               DW  @1                             ; Transfer size
 0000               DW  @2                             ; Data source address
 0000               DW  @3                             ; Transfer Completion Status Block Address
 0000               DB  0xde                           ; Reserved 
 0008           TD_ENTRY_SIZE:                         EQU 8
 0001           TD_START_SIZE:                         EQU 1
 0000           ;-----------------------------------------------
 0000           ; TD_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (restored)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   TD_INDEX_TO_OFFSET
 0000               PUSH    A                          ; Save a work register
 0000               ASL     [@0]                       ; Index * 2
 0000               ASL     [@0]                       ; Index * 4
 0000               ASL     [@0]                       ; Index * 4
 0000               POP     A                          ; Restore the work register
 0000           MACRO LT_START
 0000               DB      (@0)                       ; Table size
 0000           MACRO LT_ENTRY
 0000               DW      (@0)                       ; Table entry
 0000               DW      (@1)                       ; Table entry
 0002           LT_ENTRY_SIZE:                         EQU 2
 0001           LT_START_SIZE:                         EQU 1
 0000           
 0000           ;-----------------------------------------------
 0000           ; LT_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (not used)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   LT_INDEX_TO_OFFSET
 0000               ASL     [@0]                       ; Simply shift (mult by 2)
 0000               ASL     [@0]                       ;              (mult by 4)
 0000           MACRO DISPATCHER
 0000               CMP   A,@1
 0000               JNC   .dispatch_not_supported
 0000               ASL   A
 0000               JACC  @0
 0000           .dispatch_not_supported:
 0000               JMP  @2    
 0002           USB_bNumStringDescrs: EQU    2
 0000           
 0003           USB_NUM_ENDPOINTS:                          EQU 3 
 0002           USB_MAX_EP_NUMBER:                          EQU (USB_NUM_ENDPOINTS - 1) 
 0000           
 0000           ;--------------------------------------------------
 0000           ; Registers for USB API's.
 0000           ;--------------------------------------------------
 0074           USB_USBXCR:    EQU    USBXCR
 0040           USB_ADDR:      EQU    USBCR
 0041           USB_EP0CNT:    EQU    EP0CNT
 0042           USB_EP1CNT:    EQU    (EP0CNT + 1)
 0043           USB_EP2CNT:    EQU    (EP0CNT + 2)
 0044           USB_EP0MODE:   EQU    EP0MODE
 0045           USB_EP1MODE:   EQU    (EP0MODE + 1)
 0046           USB_EP2MODE:   EQU    (EP0MODE + 2)
 0050           USB_EP0DATA:   EQU    EP0DATA
 0058           USB_EP1DATA:   EQU    (EP0DATA + 8)
 0060           USB_EP2DATA:   EQU    (EP0DATA + 16)
 0000           
 0000           ;--------------------------------------------------
 0000           ; Endpoint 0 offsets (Table 9-2)
 0000           ;--------------------------------------------------
 0000           bmRequestType:                              EQU     0
 0001           bRequest:                                   EQU     1
 0002           wValue:                                     EQU     2
 0003           wValueHi:                                   EQU     3
 0002           wValueLo:                                   EQU     2
 0004           wIndex:                                     EQU     4
 0005           wIndexHi:                                   EQU     5
 0004           wIndexLo:                                   EQU     4
 0006           wLength:                                    EQU     6
 0007           wLengthHi:                                  EQU     7
 0006           wLengthLo:                                  EQU     6
 0000           
 0000           ;--------------------------------------------------
 0000           ; Request Types (Table 9-4)
 0000           ;--------------------------------------------------
 0000           USB_GET_STATUS:                             EQU    0x00
 0001           USB_CLEAR_FEATURE:                          EQU    0x01
 0003           USB_SET_FEATURE:                            EQU    0x03
 0005           USB_SET_ADDRESS:                            EQU    0x05
 0006           USB_GET_DESCRIPTOR:                         EQU    0x06
 0007           USB_SET_DESCRIPTOR:                         EQU    0x07
 0008           USB_GET_CONFIGURATION:                      EQU    0x08
 0009           USB_SET_CONFIGURATION:                      EQU    0x09
 000A           USB_GET_INTERFACE:                          EQU    0x0A
 000B           USB_SET_INTERFACE:                          EQU    0x0B
 000C           USB_SYNCH_FRAME:                            EQU    0x0C
 0000           
 0000           ;--------------------------------------------------
 0000           ; Descriptor Types (Table 9-5)
 0000           ;--------------------------------------------------
 0001           DESCR_TYPE_DEVICE:                          EQU     1
 0002           DESCR_TYPE_CONFIG:                          EQU     2
 0003           DESCR_TYPE_STRING:                          EQU     3
 0004           DESCR_TYPE_INTERFACE:                       EQU     4
 0005           DESCR_TYPE_ENDPOINT:                        EQU     5
 0006           DESCR_TYPE_DEVICE_QUALIFIER:                EQU     6
 0007           DESCR_TYPE_OTHER_SPEED:                     EQU     7
 0008           DESCR_TYPE_INTERFACE_POWER:                 EQU     8
 0000           
 0000           ;--------------------------------------------------
 0000           ; Feature Selectors (Table 9-6)
 0000           ;--------------------------------------------------
 0001           USB_DEVICE_REMOTE_WAKEUP:                   EQU    0x01
 0000           USB_ENDPOINT_HALT:                          EQU    0x00
 0002           USB_TEST_MODE:                              EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Device Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0000           USB_DEVICE_STATUS_BUS_POWERED:              EQU   0x00
 0001           USB_DEVICE_STATUS_SELF_POWERED:             EQU   0x01
 0002           USB_DEVICE_STATUS_REMOTE_WAKEUP:            EQU   0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0001           USB_ENDPOINT_STATUS_HALT:                   EQU    0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Directions
 0000           ;--------------------------------------------------
 0080           USB_DIR_IN:                                 EQU    0x80
 0000           USB_DIR_OUT:                                EQU    0x00
 007F           USB_DIR_UNUSED:                             EQU    0x7F
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Address Symbols 
 0000           ;--------------------------------------------------
 0000           EP0:                                        EQU    0x00
 0001           EP1:                                        EQU    0x01
 0002           EP2:                                        EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Endpoint States--These act as JACC jump values
 0000           ;--------------------------------------------------
 0000           USB_TRANS_STATE_IDLE:                       EQU     0x00         ;
 0002           USB_TRANS_STATE_CONTROL_READ:               EQU     0x02         ;
 0004           USB_TRANS_STATE_CONTROL_WRITE:              EQU     0x04         ;
 0006           USB_TRANS_STATE_NO_DATA_CONTROL:            EQU     0x06         ;
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Write flag values to indicate pending data changes
 0000           ;--------------------------------------------------
 0001           USB_ADDRESS_CHANGE_PENDING:     EQU     0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; Register Constants for USB
 0000           ;--------------------------------------------------
 0080           USB_ADDR_ENABLE:                             EQU 0x80
 0040           USB_CNT_VALID:                               EQU 0x40
 0080           USB_CNT_TOGGLE:                              EQU 0x80
 0080           USB_PULLUP_ENABLE:                           EQU 0x80
 0000           
 0000           
 0000           USB_MODE_DISABLE:                            EQU 0x00
 0001           USB_MODE_NAK_IN_OUT:                         EQU 0x01
 0002           USB_MODE_STATUS_OUT_ONLY:                    EQU 0x02
 0003           USB_MODE_STALL_IN_OUT:                       EQU 0x03
 0004           USB_MODE_RESERVED_0100:                      EQU 0x04
 0005           USB_MODE_ISO_OUT:                            EQU 0x05
 0006           USB_MODE_STATUS_IN_ONLY:                     EQU 0x06
 0007           USB_MODE_ISO_IN:                             EQU 0x07
 0008           USB_MODE_NAK_OUT:                            EQU 0x08
 0009           USB_MODE_ACK_OUT:                            EQU 0x09
 000A           USB_MODE_RESERVED_1010:                      EQU 0x0A
 000B           USB_MODE_ACK_OUT_STATUS_IN:                  EQU 0x0B
 000C           USB_MODE_NAK_IN:                             EQU 0x0C
 000D           USB_MODE_ACK_IN:                             EQU 0x0D
 000E           USB_MODE_RESERVED_1110:                      EQU 0x0E
 000F           USB_MODE_ACK_IN_STATUS_OUT:                  EQU 0x0F
 0080           USB_MODE_STALL_DATA_EP:                      EQU 0x80
 0000           
 0000           ;--------------------------------------------------
 0000           ; FORCE J/K/SE0 (Argument values)
 0000           ;--------------------------------------------------
 0002           USB_FORCE_J:                                 EQU 0x02
 0001           USB_FORCE_K:                                 EQU 0x01
 0000           USB_FORCE_SE0:                               EQU 0x00
 00FF           USB_FORCE_NONE:                              EQU 0xFF
 0001           USB_FORCE_STATE:                             EQU 0x01
 0000           
 0000           ;-----------------------------------------------
 0000           ; Endpoint event flags
 0000           ;-----------------------------------------------
 0002           NO_EVENT_ALLOWED:	equ               2
 0001           EVENT_PENDING:      equ               1
 0000           NO_EVENT_PENDING:   equ               0
 0000           
 0000           IN_BUFFER_FULL:     equ               NO_EVENT_PENDING
 0001           IN_BUFFER_EMPTY:    equ               EVENT_PENDING
 0001           OUT_BUFFER_FULL:    equ               EVENT_PENDING
 0000           OUT_BUFFER_EMPTY:   equ               NO_EVENT_PENDING
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Request Dispatch Functions, including overrides
 0000           ;--------------------------------------------------
 0001           USB_NOT_SUPPORTED:  EQU 0x01
 0002           USB_UM_SUPPLIED:    EQU 0x02
 0004           USB_APP_SUPPLIED:   EQU 0x04
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_dev_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_05: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_06: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_07: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_08: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_dev_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_03: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_04: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_05: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_08: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_09: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ifc_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_ifc_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_05: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_08: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_09: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_ifc_10: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ifc_00: equ USB_NOT_SUPPORTED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ep_00: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ep_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_ep_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_03: equ USB_UM_SUPPLIED
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Standard Requests
 0000           ;-----------------------------------------------
 0001           USB_CB_h2d_std_dev: equ 1
 0001           USB_CB_h2d_std_ifc: equ 1
 0001           USB_CB_h2d_std_ep:  equ 1
 0000           USB_CB_h2d_std_oth: equ 0
 0001           USB_CB_d2h_std_dev: equ 1
 0001           USB_CB_d2h_std_ifc: equ 1
 0001           USB_CB_d2h_std_ep:  equ 1
 0000           USB_CB_d2h_std_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Class Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_cls_dev: equ 0
 0000           USB_CB_h2d_cls_ifc: equ 0
 0000           USB_CB_h2d_cls_ep:  equ 0
 0000           USB_CB_h2d_cls_oth: equ 0
 0000           USB_CB_d2h_cls_dev: equ 0
 0000           USB_CB_d2h_cls_ifc: equ 0
 0000           USB_CB_d2h_cls_ep:  equ 0
 0000           USB_CB_d2h_cls_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_vnd_dev: equ 0
 0000           USB_CB_h2d_vnd_ifc: equ 0
 0000           USB_CB_h2d_vnd_ep:  equ 0
 0000           USB_CB_h2d_vnd_oth: equ 0
 0000           USB_CB_d2h_vnd_dev: equ 0
 0000           USB_CB_d2h_vnd_ifc: equ 0
 0000           USB_CB_d2h_vnd_ep:  equ 0
 0000           USB_CB_d2h_vnd_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Reserved Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_rsv_dev: equ 0
 0000           USB_CB_h2d_rsv_ifc: equ 0
 0000           USB_CB_h2d_rsv_ep:  equ 0
 0000           USB_CB_h2d_rsv_oth: equ 0
 0000           USB_CB_d2h_rsv_dev: equ 0
 0000           USB_CB_d2h_rsv_ifc: equ 0
 0000           USB_CB_d2h_rsv_ep:  equ 0
 0000           USB_CB_d2h_rsv_oth: equ 0
 0000           
 0000           ;--------------------------------------------------
 0000           ; Transfer Descriptor--Data Source
 0000           ;--------------------------------------------------
 0000           USB_DS_ROM:                                      EQU 0x00
 0001           USB_DS_RAM:                                      EQU 0x01
 0002           USB_DS_RAM_CB:                                   EQU 0x02
 0003           USB_DS_RAM_MASK:                                 EQU 0x03
 0000           
 0000           ;-----------------------------------------------
 0000           ; Transfer Completion Notification
 0000           ;-----------------------------------------------
 0000           USB_XFER_IDLE:         equ      0x00
 0001           USB_XFER_STATUS_ACK:   equ      0x01
 0002           USB_XFER_PREMATURE:    equ      0x02
 0003           USB_XFER_ERROR:        equ      0x03
 0000           
 0000           ; This macro is used to allocate a completion status block
 0000           ; for all Requests.  The macro parameter is used
 0000           ; to prefix the two data elements.
 0000           USB_XFER_STATUS:       equ      0
 0001           USB_XFER_LENGTH:       equ      1
 0000           MACRO    USB_XFER_STATUS_BLOCK
 0000               BLK    1    ; Completion Status
 0000               BLK    2    ; Transfer Length
 0000           USB_CLASS_NONE:                        EQU    0x00
 0001           USB_CLASS_HID:                         EQU    0x01
 0000           USB_CLASS:                             EQU    USB_CLASS_NONE
 0000           
 0000           ;-----------------------------------------------
 0000           ; Modify the supported requests by redefining
 0000           ; them within the custom code area below
 0000           ;-----------------------------------------------
 0000           
 0000              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code below this banner
 0000              ;---------------------------------------------------
 0000              ;   NOTE: interrupt service routines must preserve
 0000              ;   the values of the A and X CPU registers.
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code above this banner
 0000              ;---------------------------------------------------
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function below this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              
 0000              ;PRESERVE_CPU_CONTEXT
 0000              ;lcall _My_C_Function
 0000              ;RESTORE_CPU_CONTEXT
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function above this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              ;@PSoC_UserCode_END@ (Do not change this line.)
 0000           ;-----------------------------------------------
 0000           ; Has the user enabled any of the Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_VSR_SUPPORT: EQU 0
                IF USB_CB_h2d_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                
                ; end of file USB.inc
                IF 0x2 & 0x10000000
                PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
                ; This message will only appear if the USB Setup Wizard has not be run and the descriptors
                ; and associated data structures have been created.
                ; After running the USB Setup Wizard, you must also select the Config/Generate Application
                ; menu item from PSoC Designer in order to generate USB User Module data structures and
                ; descriptors.
                ENDIF
                ;-----------------------------------------------
                ;  Global Symbols
                ;-----------------------------------------------
                EXPORT USB_Start
                EXPORT _USB_Start
                EXPORT USB_Stop
                EXPORT _USB_Stop
                EXPORT USB_bCheckActivity
                EXPORT _USB_bCheckActivity
                EXPORT USB_bGetConfiguration
                EXPORT _USB_bGetConfiguration
                EXPORT USB_bGetEPState
                EXPORT _USB_bGetEPState
                EXPORT USB_bGetEPCount
                EXPORT _USB_bGetEPCount
                EXPORT USB_XLoadEP
                EXPORT _USB_XLoadEP
                EXPORT  USB_bReadOutEP
                EXPORT _USB_bReadOutEP
                EXPORT  USB_bGetEPAckState
                EXPORT _USB_bGetEPAckState
                EXPORT  USB_SetPowerStatus
                EXPORT _USB_SetPowerStatus
                EXPORT USB_EnableOutEP
                EXPORT _USB_EnableOutEP
                EXPORT USB_DisableOutEP
                EXPORT _USB_DisableOutEP
                EXPORT USB_EnableEP
                EXPORT _USB_EnableEP
                EXPORT USB_DisableEP
                EXPORT _USB_DisableEP
                EXPORT USB_Force
                EXPORT _USB_Force
                EXPORT USB_Suspend
                EXPORT _USB_Suspend
                EXPORT USB_Resume
                EXPORT _USB_Resume
                EXPORT USB_bRWUEnabled
                EXPORT _USB_bRWUEnabled
                
                AREA bss (RAM,REL)
                ;-----------------------------------------------
                ;  Variable Allocation
                ;-----------------------------------------------
                ;----------------------------------------------------------------------------
                EXPORT USB_APITemp
 0000            USB_APITemp:                          BLK   2 ; Two bytes of temporary
 0002                                                           ; storage shared by the API
 0002                                                           ; functions
                EXPORT USB_APIEPNumber, _USB_APIEPNumber
 0002           _USB_APIEPNumber:
 0002            USB_APIEPNumber:                      BLK   1 ; API storage for speed
                EXPORT USB_APICount, _USB_APICount
 0003           _USB_APICount:
 0003            USB_APICount:                         BLK   1 ; API storage for speed
 0004           
                EXPORT USB_bActivity
 0004            USB_bActivity:                        BLK   1 ; Activity flag (Shared between the ISR and API)
 0005           ;-----------------------------------------------
 0005           ;  Constant Data Allocation
 0005           ;-----------------------------------------------
                AREA UserModules (ROM, REL)
                EXPORT USB_USB_EP_BIT_LOOKUP
 0000           .LITERAL
 0000           USB_USB_EP_BIT_LOOKUP:  ;
 0000 01            DB     01H                       ; EP0
 0001 02            DB     02H                       ; EP1
 0002 04            DB     04H                       ; EP2
 0003           .ENDLITERAL
 0003           
                AREA UserModules (ROM, REL)
                
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_Start
                ;
                ;  DESCRIPTION:    Starts the USB User Module
                ;                    Sets the device selection
                ;                    Set the configuration to unconfigured
                ;                    Enables the SIE for Address 0
                ;                    Enables the USB pullup (D- for low speed, D+ for full speed)
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:    A is the desired device setting
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
 0003           .SECTION
 0003            USB_Start:
 0003           _USB_Start:
 0003 620D00        MOV    REG[P10CR], 0x00            ; Disable the states
 0006 620E00        MOV    REG[P11CR], 0x00            ; 
 0009           
 0009 5300          MOV     [USB_bCurrentDevice], A    ; The app selects the desired device
 000B           
 000B 550000        MOV     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
 000E 550000        MOV     [USB_Configuration], 0     ; Unconfigured
 0011 550000        MOV     [USB_DeviceStatus], 0      ; Clears device status
 0014           
 0014 550000        MOV     [USB_EPDataToggle], 0      ; Clear all EP data toggles
 0017           
                IF (USB_CLASS & USB_CLASS_HID)
                    ; Initialize USB_Protocol variable to comply with HID 7.2.6 Set_Protocol Request: 
                    ; "When initialized, all devices default to report protocol." 
                    mov     X, 1-1                     ;number of interfaces -1 
                .loop:
                    mov     [X + USB_Protocol], 1      ; Protocol = Report
                    dec     X                                ;Are we done?
                    jnc     .loop                            ;Jump to do another interface
                ENDIF
                    
                ; Flow here to enable the SIE
 0017 624080        MOV     REG[USB_ADDR], USB_ADDR_ENABLE ; Enable Address 0
 001A 437480        OR      REG[USB_USBXCR], USB_PULLUP_ENABLE ; Pullup D-
 001D 624403        MOV     REG[USB_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
 0020 40            NOP
 0021 5D44          MOV     A, REG[USB_EP0MODE]        ; Read the mode register as a debug marker
 0023           
 0023 43E119        or    reg[INT_MSK1], (INT_MSK1_USB_ACTIVITY | INT_MSK1_USB_BUS_RESET | INT_MSK1_USB_EP0)               ; enable specified interrupt enable bit
 0026 7F            RET
 0027           .ENDSECTION
 0027           ;-----------------------------------------------------------------------------
 0027           ;  FUNCTION NAME: USB_Stop
 0027           ;
 0027           ;  DESCRIPTION:
 0027           ;
 0027           ;-----------------------------------------------------------------------------
 0027           ;
 0027           ;  ARGUMENTS:
 0027           ;
 0027           ;  RETURNS:
 0027           ;
 0027           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0027           ;
 0027           ;  THEORY of OPERATION or PROCEDURE:
 0027           ;
 0027           ;-----------------------------------------------------------------------------
 0027           .SECTION
 0027            USB_Stop:
 0027           _USB_Stop:
 0027 550000        MOV     [USB_bCurrentDevice], 0    ; The app selects the desired device
 002A           
 002A 550000        MOV     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
 002D 550000        MOV     [USB_Configuration], 0     ; Unconfigured
 0030 550000        MOV     [USB_DeviceStatus], 0      ; Clear the  device status
 0033 550400        MOV     [USB_bActivity], 0         ; Clear the activity flag
 0036 624000        MOV     REG[USB_ADDR], 0           ; Clear the addfress and Address 0
 0039 41747F        AND     REG[USB_USBXCR], ~USB_PULLUP_ENABLE ; Release D-
 003C 41E1E0        and   reg[INT_MSK1], ~(INT_MSK1_USB_ACTIVITY | INT_MSK1_USB_BUS_RESET | INT_MSK1_USB_EP0 | INT_MSK1_USB_EP1 | INT_MSK1_USB_EP2)              ; disable specified interrupt enable bit
 003F           
 003F 7F            RET
 0040           .ENDSECTION
 0040           ;-----------------------------------------------------------------------------
 0040           ;  FUNCTION NAME: USB_bCheckActivity
 0040           ;
 0040           ;  DESCRIPTION:
 0040           ;
 0040           ;-----------------------------------------------------------------------------
 0040           ;
 0040           ;  ARGUMENTS:
 0040           ;
 0040           ;  RETURNS:
 0040           ;
 0040           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0040           ;
 0040           ;  THEORY of OPERATION or PROCEDURE:
 0040           ;
 0040           ;   The activity interrupt sets a RAM flag indicating activity and disables the
 0040           ;   interrupt.  Disabling the interrupt keeps the bus activity from creating too
 0040           ;   many interrupts.  bCheckActivity checks and clears the flag, the enables
 0040           ;   interrupts for the next interval.
 0040           ;
 0040           ;-----------------------------------------------------------------------------
 0040           .SECTION
 0040            USB_bCheckActivity:
 0040           _USB_bCheckActivity:
 0040 5104          MOV    A, [USB_bActivity]          ; Activity?
 0042 3901          CMP    A, 1                        ; 
 0044 A002          JZ     .active                     ; Jump on Activity
 0046           ; Flow here on no activity
 0046 7F            RET
 0047           ; Jump here if activity was detected
 0047           .active:
 0047 550400        MOV    [USB_bActivity], 0          ; Clear the activity flag for next time
 004A 43E110        or    reg[INT_MSK1], INT_MSK1_USB_ACTIVITY               ; enable specified interrupt enable bit
 004D 7F            RET
 004E           .ENDSECTION
 004E           ;-----------------------------------------------------------------------------
 004E           ;  FUNCTION NAME: USB_bGetConfiguration
 004E           ;
 004E           ;  DESCRIPTION:   Returns the current configuration number
 004E           ;
 004E           ;-----------------------------------------------------------------------------
 004E           ;
 004E           ;  ARGUMENTS:    None
 004E           ;
 004E           ;  RETURNS:      A contains the current configuration number
 004E           ;
 004E           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 004E           ;
 004E           ;  THEORY of OPERATION or PROCEDURE:
 004E           ;
 004E           ;-----------------------------------------------------------------------------
 004E           .SECTION
 004E            USB_bGetConfiguration:
 004E           _USB_bGetConfiguration:
 004E 5100          MOV     A,[USB_Configuration]
 0050 7F            RET
 0051           .ENDSECTION
 0051           ;-----------------------------------------------------------------------------
 0051           ;  FUNCTION NAME: USB_bGetEPState
 0051           ;
 0051           ;  DESCRIPTION:   Returns the current endpoint state
 0051           ;
 0051           ;-----------------------------------------------------------------------------
 0051           ;
 0051           ;  ARGUMENTS:   A: Endpoint Number
 0051           ;
 0051           ;  RETURNS:     A: NO_EVENT_ALLOWED
 0051           ;                  EVENT_PENDING
 0051           ;                  NO_EVENT_PENDING
 0051           ;
 0051           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0051           ;
 0051           ;  THEORY of OPERATION or PROCEDURE:
 0051           ;
 0051           ;-----------------------------------------------------------------------------
 0051           .SECTION
 0051            USB_bGetEPState:
 0051           _USB_bGetEPState:
 0051 3903          CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
 0053 D006          JNC     .invalid_ep                ; Bail out
 0055           ; Flow here to enable an endpoint        
 0055 5C            MOV     X, A                       ; Endpoint number is the index
 0056 5200          MOV     A, [X+USB_EndpointAPIStatus]; Get the state
 0058 8003          JMP     .exit                      ; Go to the common exit
 005A           ; Jump here for an invalid endpoint
 005A           .invalid_ep:
 005A 5000          MOV     A, 0                       ; Return 0 for an invalid ep
 005C           ; Jump or flow here for a common exit
 005C           .exit:
 005C 7F            RET                                ; All done
 005D           .ENDSECTION
 005D           ;-----------------------------------------------------------------------------
 005D           ;  FUNCTION NAME: USB_bRWUEnabled
 005D           ;
 005D           ;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
 005D           ;
 005D           ;-----------------------------------------------------------------------------
 005D           ;
 005D           ;  ARGUMENTS:   None
 005D           ;
 005D           ;  RETURNS:     A: 1--Remote Wake Up Enabled
 005D           ;                  0--Remote Wake Up Disabled
 005D           ;
 005D           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 005D           ;
 005D           ;  THEORY of OPERATION or PROCEDURE:
 005D           ;
 005D           ;-----------------------------------------------------------------------------
 005D           .SECTION
 005D            USB_bRWUEnabled:
 005D           _USB_bRWUEnabled:
 005D 470002        TST     [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
 0060 B005          JNZ     .enabled                   ; Jump if enabled
 0062           ; Flow here if RWU is disabled        
 0062 5000          MOV     A, 0                       ; Return disabled
 0064 8003          JMP     .exit                      ; Go to the common exit
 0066           ; Jump when RWU is enabled
 0066           .enabled:
 0066 5001          MOV     A, 1                       ; Return enabled
 0068           ; Jump or flow here for a common exit
 0068           .exit:
 0068 7F            RET                                ; All done
 0069           .ENDSECTION
 0069           ;-----------------------------------------------------------------------------
 0069           ;  FUNCTION NAME: USB_bGetEPCount
 0069           ;
 0069           ;  DESCRIPTION:
 0069           ;
 0069           ;-----------------------------------------------------------------------------
 0069           ;
 0069           ;  ARGUMENTS:
 0069           ;
 0069           ;  RETURNS:
 0069           ;
 0069           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0069           ;
 0069           ;  THEORY of OPERATION or PROCEDURE:
 0069           ;
 0069           ;-----------------------------------------------------------------------------
 0069           .SECTION
 0069            USB_bGetEPCount:
 0069           _USB_bGetEPCount:
 0069 3903          CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
 006B D00A          JNC     .invalid_ep                ; Bail out
 006D           ; Flow here to get the endpoint count
 006D 5C            MOV     X, A                       ; Endpoint number is the index
 006E 5E41          MOV     A, REG[X+EP0CNT]           ; Here is the count
 0070 211F          AND     A, 0x1F                    ; Mask off the count
 0072 1102          SUB     A, 2                       ; Ours includes the two byte checksum
 0074 8003          JMP     .exit                      ; Go to the common exit
 0076           ; Jump here for an invalid endpoint
 0076           .invalid_ep:
 0076 5000          MOV     A, 0                       ; Return 0 for an invalid ep
 0078           ; Jump or flow here for a common exit
 0078           .exit:
 0078 7F            RET
 0079           .ENDSECTION
 0079           ;-----------------------------------------------------------------------------
 0079           ;  FUNCTION NAME: USB_LoadEP
 0079           ;
 0079           ;  DESCRIPTION:    This function loads the specified endpoint buffer
 0079           ;                  with the number of bytes previously set in the count
 0079           ;                  register.
 0079           ;
 0079           ;-----------------------------------------------------------------------------
 0079           ;
 0079           ;  ARGUMENTS:  A:X Pointer to the ram buffer containing the data to transfer
 0079           ;              USB_APIEPNumber loaded with the endpoint number
 0079           ;              USB_APICount loaded with the number of bytes to load
 0079           ;
 0079           ;  RETURNS:    NONE
 0079           ;
 0079           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0079           ;
 0079           ;  THEORY of OPERATION or PROCEDURE:
 0079           ;
 0079           ;-----------------------------------------------------------------------------
 0079           .SECTION
 0079            USB_XLoadEP:
 0079           _USB_XLoadEP:
 0079           ; extern void USB_LoadEP(BYTE, BYTE*);
 0079 3C0203        CMP     [USB_APIEPNumber], (USB_MAX_EP_NUMBER + 1) ; Range check
 007C D03F          JNC     .exit                      ; Bail out
 007E           ; Flow here to get the endpoint count
 007E 5A00          MOV     [USB_APITemp], X           ; Use this temp as the MVI pointer
 0080           
 0080 5102          MOV     A, [USB_APIEPNumber]       ; Get the endpoint number
 0082 F039          INDEX   EPREGPTR                   ; Get the address of the endpoint data register array
 0084 5C            MOV     X, A                       ; We are going to use index access to the register array
 0085               
 0085 5103          MOV     A, [USB_APICount]          ; Get the count
 0087 5301          MOV     [USB_APITemp+1], A         ; Use this temp as the count
 0089           ; Copy loop
 0089           .loop:
 0089 7A01          DEC     [USB_APITemp+1]            ; Are we done?
 008B C008          JC      .done                      ; Jump if we are
 008D 3E00          MVI     A, [USB_APITemp]           ; Get the data, inc the pointer
 008F 6100          MOV     REG[X + 0], A              ; Store the data
 0091 75            INC     X                          ; Index the next data register
 0092 8FF6          JMP     .loop                      ; Copy the next byte or finish
 0094           
 0094           ; Jump here when the copy is finished
 0094           .done:
 0094 5802          MOV     X, [USB_APIEPNumber]       ; Get the endpoint number
 0096 5B            MOV     A, X
 0097 FF67          INDEX   USB_USB_EP_BIT_LOOKUP
 0099 2200          AND     A, [USB_EPDataToggle]
 009B A003          JZ      .addcount
 009D 5080          MOV     A, USB_CNT_TOGGLE
 009F           
 009F           .addcount:     
 009F 2A03          OR      A, [USB_APICount]          ; Get the count
 00A1 6141          MOV     REG[X + EP0CNT], A         ; Update the count register
 00A3           
 00A3 560000        MOV     [X + USB_EndpointAPIStatus], NO_EVENT_PENDING ; Set the state
 00A6           
 00A6 5DF7          MOV     A, REG[0xF7]  ; save GIE state
 00A8 5300          MOV     [USB_APITemp], A  ; save GIE state
 00AA 70FE          and   F, ~FLAG_GLOBAL_IE
 00AC           .write_again:
 00AC 63440D        MOV     REG[X + EP0MODE], USB_MODE_ACK_IN ; Enable the endpoint
 00AF 5E44          MOV     A, REG[X + EP0MODE]
 00B1 390D          CMP     A, USB_MODE_ACK_IN
 00B3 BFF8          JNZ     .write_again
 00B5 470001        TST     [USB_APITemp], 0x01
 00B8 A003          JZ      .exit
 00BA 7101          or    F, FLAG_GLOBAL_IE
 00BC           
 00BC           ; Jump or flow here for a common exit
 00BC           .exit:
 00BC 7F            RET
 00BD           .LITERAL
 00BD 505860    EPREGPTR:    DB    EP0DATA, EP1DATA, EP2DATA
 00C0           .ENDLITERAL
 00C0           .ENDSECTION
 00C0           ;-----------------------------------------------------------------------------
 00C0           ;  FUNCTION NAME: USB_EnableEP
 00C0           ;
 00C0           ;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
 00C0           ;                  called for an IN endpoint.
 00C0           ;
 00C0           ;-----------------------------------------------------------------------------
 00C0           ;
 00C0           ;  ARGUMENTS:      A contains the endpoint number
 00C0           ;
 00C0           ;  RETURNS:        None
 00C0           ;
 00C0           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00C0           ;
 00C0           ;  THEORY of OPERATION or PROCEDURE:
 00C0           ;
 00C0           ;-----------------------------------------------------------------------------
 00C0           .SECTION
 00C0            USB_EnableOutEP:
 00C0           _USB_EnableOutEP:
 00C0            USB_EnableEP:
 00C0           _USB_EnableEP:
 00C0 3900          CMP     A, 0                       ; Can't enable EP0
 00C2 A00E          JZ      .exit                      ; Bail out
 00C4 3903          CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
 00C6 D00A          JNC     .exit                      ; Bail out
 00C8           ; Flow here to enable an endpoint        
 00C8 5C            MOV     X, A                       ; Endpoint number is the index
 00C9 560000        MOV     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
 00CC 5E44          MOV     A, REG[X+EP0MODE]          ; Unlock the mode register
 00CE 634409        MOV     REG[X+EP0MODE], USB_MODE_ACK_OUT ; Enable the endpoint
 00D1           ; Jump or flow here for a common exit
 00D1           .exit:
 00D1 7F            RET                                ; All done
 00D2           .ENDSECTION
 00D2           ;-----------------------------------------------------------------------------
 00D2           ;  FUNCTION NAME: USB_DisableEP
 00D2           ;
 00D2           ;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
 00D2           ;                  called for an IN endpoint.
 00D2           ;
 00D2           ;-----------------------------------------------------------------------------
 00D2           ;
 00D2           ;  ARGUMENTS:
 00D2           ;
 00D2           ;  RETURNS:
 00D2           ;
 00D2           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00D2           ;
 00D2           ;  THEORY of OPERATION or PROCEDURE:
 00D2           ;
 00D2           ;-----------------------------------------------------------------------------
 00D2           .SECTION
 00D2            USB_DisableOutEP:
 00D2           _USB_DisableOutEP:
 00D2            USB_DisableEP:
 00D2           _USB_DisableEP:
 00D2 3900          CMP     A, 0                       ; Can't disable EP0
 00D4 A00B          JZ      .exit                      ; Bail out
 00D6 3903          CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
 00D8 D007          JNC     .exit                      ; Bail out
 00DA           ; Flow here to disable an endpoint        
 00DA 5C            MOV     X, A                       ; Endpoint number is the index
 00DB 5E44          MOV     A, REG[X+EP0MODE]          ; Unlock the mode register
 00DD 634408        MOV     REG[X+EP0MODE], USB_MODE_NAK_OUT ; Disable the endpoint
 00E0           ; Jump or flow here for a common exit
 00E0           .exit:
 00E0 7F            RET                                ; All done
 00E1           .ENDSECTION
 00E1           ;-----------------------------------------------------------------------------
 00E1           ;  FUNCTION NAME: USB_Force
 00E1           ;
 00E1           ;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
 00E1           ;
 00E1           ;-----------------------------------------------------------------------------
 00E1           ;
 00E1           ;  ARGUMENTS:     A: USB_FORCE_J
 00E1           ;                    USB_FORCE_K
 00E1           ;                    USB_FORCE_SE0
 00E1           ;                    USB_FORCE_NONE
 00E1           ;
 00E1           ;  RETURNS:       Nothing
 00E1           ;
 00E1           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00E1           ;
 00E1           ;  THEORY of OPERATION or PROCEDURE:
 00E1           ;
 00E1           ;-----------------------------------------------------------------------------
 00E1           .SECTION
 00E1            USB_Force:
 00E1           _USB_Force:
 00E1 39FF          CMP    A, USB_FORCE_NONE           ; Are we done forcing D+/D-?
 00E3 A028          JZ     .none                       ; Jump if we are done
 00E5           ; Flow here to start checking 
 00E5 3902          CMP    A, USB_FORCE_J              ; Force J?
 00E7 B009          JNZ    .check_k                    ; Jump if not J
 00E9           ; Flow here to force J
 00E9 2E0002        OR     [Port_1_Data_SHADE], 0x02   ; D- = 1
 00EC 2600FE        AND    [Port_1_Data_SHADE], ~(0x01); D+ = 0
 00EF 8014          JMP    .force                      ; Go set the force register
 00F1           ; Jump here to check Force K
 00F1           .check_k:
 00F1 3901          CMP    A, USB_FORCE_K              ; Force K?
 00F3 B009          JNZ    .check_se0                  ; Jump if not K
 00F5           ; Flow here to force K
 00F5 2E0001        OR     [Port_1_Data_SHADE], 0x01   ; D+ = 1
 00F8 2600FD        AND    [Port_1_Data_SHADE], ~(0x02); D- = 0
 00FB 8008          JMP    .force                      ; Go set the force register
 00FD           ; Jump here to check Force SE0
 00FD           .check_se0:
 00FD 3900          CMP    A, USB_FORCE_SE0            ; Force SE0?
 00FF A00F          JZ     .invalid                    ; Jump if not SE0
 0101           ; Flow here to force SE0
 0101 2600FC        AND    [Port_1_Data_SHADE], ~(0x03); D- = 0,  D+ = 0
 0104           ; Jump or flow here to enable forcing (Port bits are set in the shadow register)
 0104           .force:
 0104 5100          MOV    A, [Port_1_Data_SHADE]      ; Get the shadow
 0106 6001          MOV    REG[P1DATA], A              ; Update the port
 0108 437401        OR     REG[USBXCR], USB_FORCE_STATE; Enable FORCING D+/D-
 010B 7F            RET                                ; Exit
 010C           ; Jump here to clear forcing
 010C           .none:
 010C 4174FE        AND    REG[USBXCR], ~(USB_FORCE_STATE) ; Disable FORCING D+/D-
 010F           ; Jump or flow here to exit on end forcing or an invalid parameter
 010F           .invalid:
 010F 7F            RET                                ; Exit
 0110           .ENDSECTION
 0110           ;-----------------------------------------------------------------------------
 0110           ;  FUNCTION NAME: USB_Suspend
 0110           ;
 0110           ;  DESCRIPTION:    Puts the USB Transceiver into power-down mode, while
 0110           ;                  maintaining the USB address assigned by the USB host. 
 0110           ;                  To restore the USB Transceiver to normal operation, the
 0110           ;                  USB_Resume function should be called.
 0110           ;
 0110           ;-----------------------------------------------------------------------------
 0110           ;
 0110           ;  ARGUMENTS:     None
 0110           ;
 0110           ;  RETURNS:       Nothing
 0110           ;
 0110           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0110           ;
 0110           ;  THEORY of OPERATION or PROCEDURE:
 0110           ;
 0110           ;-----------------------------------------------------------------------------
 0110           .SECTION
 0110            USB_Suspend:
 0110           _USB_Suspend:
 0110 41407F        AND     REG[USB_ADDR], ~(USB_ADDR_ENABLE) ; Disable transceiver
 0113 7F            RET                                ; Exit
 0114           .ENDSECTION
 0114           ;-----------------------------------------------------------------------------
 0114           ;  FUNCTION NAME: USB_Resume
 0114           ;
 0114           ;  DESCRIPTION:    Puts the USB Transceiver into normal operation, following
 0114           ;                  a call to USB_Suspend. It retains the USB address that had
 0114           ;                  been assigned by the USB host.
 0114           ;
 0114           ;-----------------------------------------------------------------------------
 0114           ;
 0114           ;  ARGUMENTS:     None
 0114           ;
 0114           ;  RETURNS:       Nothing
 0114           ;
 0114           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0114           ;
 0114           ;  THEORY of OPERATION or PROCEDURE:
 0114           ;
 0114           ;-----------------------------------------------------------------------------
 0114           .SECTION
 0114            USB_Resume:
 0114           _USB_Resume:
 0114 434080        OR     REG[USB_ADDR], (USB_ADDR_ENABLE) ; Enable transceiver
 0117 7F            RET                                ; Exit
 0118           .ENDSECTION
 0118           
 0118           ;-----------------------------------------------------------------------------
 0118           ;  FUNCTION NAME: USB_bReadOutEP
 0118           ;
 0118           ;  DESCRIPTION:    This function reads the data from the USB Out endpoint
 0118           ;                  and loads it into the specified buffer.
 0118           ;
 0118           ;-----------------------------------------------------------------------------
 0118           ;
 0118           ;  ARGUMENTS:
 0118           ;     [SP-6] Count to read
 0118           ;     [SP-5] MSB of data array address to put data in
 0118           ;     [SP-4] LSB of data array address to put data in
 0118           ;     [SP-3] Endpoint Number
 0118           ;
 0118           ;  RETURNS:   The number of bytes sent by the host
 0118           ;
 0118           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0118           ;
 0118           .SECTION
 0118           
 FFFFFFFD           EP_NUMR:     equ -3           ; Endpoint Number
 FFFFFFFC           DATA_LSBR:   equ -4           ; MSB pointer of data
 FFFFFFFB           DATA_MSBR:   equ -5           ; LSB pointer of data
 FFFFFFFA           CNT_LENR:    equ -6           ; Length of data to send
 0118           
 000F           BYTE_CNT_BITMASK:   equ 0x0F
 0002           BYTE_CNT_CHKSUM:    equ 0x02
 0118            USB_bReadOutEP:
 0118           _USB_bReadOutEP:
 0118           
 0118 4F            MOV     X, SP
 0119 52FD          MOV     A, [X+EP_NUMR]
 011B 3903          CMP     A, USB_MAX_EP_NUMBER+1     ; Range check
 011D D02F          JNC     .exit                      ; Bail out
 011F           
 011F               ;Get the count value passed
 011F 52FA          MOV     A, [X+CNT_LENR]            ; Get the Count
 0121 5300          MOV     [USB_APITemp], A           ; Save the count
 0123           
 0123               ;Determine which is smaller the requested data or the available data
 0123 52FD          MOV     A, [X+EP_NUMR]              ; Get the Endpoint number
 0125 5C            MOV     X, A                        ; Make it into an index
 0126 5E41          MOV     A, reg[X+USB_EP0CNT]        ; Get the Real count
 0128 210F          AND     A, BYTE_CNT_BITMASK         ; Mask off the count bits
 012A 1102          SUB     A, BYTE_CNT_CHKSUM         ; Count includes the two byte checksum    
 012C 5303          MOV     [USB_APICount], A           ; Save the Real count of bytes sent by the host
 012E 3A00          CMP     A, [USB_APITemp]            ; Are they equal
 0130 D003          JNC     .CountDetermined            ;If the requested count is smaller use it
 0132 5300          MOV     [USB_APITemp], A            ; Else use the actual
 0134           
 0134           .CountDetermined:
 0134               ; Now we are ready to start moving data
 0134 5100          MOV     A, [USB_APITemp]            ; Check the Count
 0136 A016          JZ      .done                       ; If it is 0 then we have a 0 length packet
 0138           
 0138 4F            MOV     X, SP                       ; Get the Stack Pointer
 0139 52FC          MOV     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
 013B 5301          MOV     [USB_APITemp+1], A          ; Save the LSB of the pointer
 013D               
 013D 52FD          MOV     A, [X+EP_NUMR]              ; Get the Endpoint number
 013F FF7C          INDEX   EPREGPTR                      ; Get the address of the endpoint data register array
 0141 5C            MOV     X, A                          ; We are going to use index access to the register array    
 0142               
 0142           .loop:
 0142 5E00          MOV     A, reg[X]                   ; Get the data from the EP Data Buffer
 0144 3F01          MVI     [USB_APITemp+1], A          ; save it in data array
 0146 75            INC     X                           ; increment the pointer
 0147 7A00          DEC     [USB_APITemp]               ; decrement the counter
 0149 BFF8          JNZ     .loop                       ; wait for count to zero out
 014B           
 014B           
 014B 5103          MOV     A, [USB_APICount]           ; Get the Real count LSB
 014D           .done:
 014D           .exit:
 014D 7F            RET
 014E           .ENDSECTION
 014E           
 014E           ;-----------------------------------------------------------------------------
 014E           ;  FUNCTION NAME: USB_bGetEPAckState
 014E           ;
 014E           ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
 014E           ;                 an endpoint
 014E           ;
 014E           ;-----------------------------------------------------------------------------
 014E           ;
 014E           ;  ARGUMENTS:     A is the Endpoint Number
 014E           ;
 014E           ;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
 014E           ;
 014E           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 014E           ;
 014E           .SECTION
 0010           ACK_BITMASK:    equ 0x10
 014E            USB_bGetEPAckState:
 014E           _USB_bGetEPAckState:
 014E 5C            mov    X, A
 014F 5E44          mov    A, reg[X + USB_EP0MODE]
 0151 2110          and    A, ACK_BITMASK ; Get ACK bit
 0153 7F            ret                                ; Exit
 0154           .ENDSECTION
 0154           
 0154           ;-----------------------------------------------------------------------------
 0154           ;  FUNCTION NAME: USB_SetPowerStatus
 0154           ;
 0154           ;  DESCRIPTION:    Set The Current Power status.
 0154           ;
 0154           ;-----------------------------------------------------------------------------
 0154           ;
 0154           ;  ARGUMENTS:      A contains the power status
 0154           ;
 0154           ;  RETURNS:        None
 0154           ;
 0154           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0154           ;
 0154           .SECTION
 0154            USB_SetPowerStatus:
 0154           _USB_SetPowerStatus:
 0154 3900          cmp     A, USB_DEVICE_STATUS_BUS_POWERED     
 0156 A006          jz      .bus_powered
 0158 2E0001        or      [USB_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
 015B 8004          jmp     .done
 015D           .bus_powered:
 015D 2600FE        and     [USB_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
 0160           .done:
 0160 7F            ret                                ; All done
 0161           .ENDSECTION
 0161           
 0161           ;-----------------------------------------------
 0161           ; Add custom application code for routines 
 0161           ;-----------------------------------------------
 0161           
 0161              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 0161              ;---------------------------------------------------
 0161              ; Insert your custom code below this banner
 0161              ;---------------------------------------------------
 0161           
 0161              ;---------------------------------------------------
 0161              ; Insert your custom code above this banner
 0161              ;---------------------------------------------------
 0161              ;@PSoC_UserCode_END@ (Do not change this line.)
 0161           
 0161           ; End of File USB.asm
