 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           ;;  FILENAME: USB_std.asm
 0000           ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
 0000           ;;  Generated by PSoC Designer 5.4.3191
 0000           ;;
 0000           ;;  DESCRIPTION: USB Device User Module software implementation file
 0000           ;;
 0000           ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
 0000           ;;        arguments and observe the associated "Registers are volatile" policy.
 0000           ;;        This means it is the caller's responsibility to preserve any values
 0000           ;;        in the X and A registers that are still needed after the API
 0000           ;;        function returns. Even though these registers may be preserved now,
 0000           ;;        there is no guarantee they will be preserved in future releases.
 0000           ;;-----------------------------------------------------------------------------
 0000           ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           
 0010           FLAG_XIO_MASK:  equ 10h
 0008           FLAG_SUPER:     equ 08h
 0004           FLAG_CARRY:     equ 04h
 0002           FLAG_ZERO:      equ 02h
 0001           FLAG_GLOBAL_IE: equ 01h
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 0
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;------------------------------------------------
 0000           ; Port Data Registers
 0000           P0DATA:       equ 00h          ; Port 0 Data Register                     (RW)
 0001           P1DATA:       equ 01h          ; Port 1 Data Register                     (RW)
 0002           P2DATA:       equ 02h          ; Port 2 Data Register                     (RW)
 0003           P3DATA:       equ 03h          ; Port 3 Data Register                     (RW)
 0004           P4DATA:       equ 04h          ; Port 4 Data Register                     (RW)
 0000           ; PSoC Compatability
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)(PSoC)
 0001           PRT1DR:       equ 01h          ; Port 1 Data Register                     (RW)(PSoC)
 0002           PRT2DR:       equ 02h          ; Port 2 Data Register                     (RW)(PSoC)
 0003           PRT3DR:       equ 03h          ; Port 3 Data Register                     (RW)(PSoC)
 0004           PRT4DR:       equ 04h          ; Port 4 Data Register                     (RW)(PSoC)
 0000           
 0000           ; Port/Pin Configuration Registers
 0005           P00CR:        equ 05h          ; P0.0 Configuration Register              (RW)
 0006           P01CR:        equ 06h          ; P0.1 Configuration Register              (RW)
 0007           P02CR:        equ 07h          ; P0.2 Configuration Register              (RW)
 0008           P03CR:        equ 08h          ; P0.3 Configuration Register              (RW)
 0009           P04CR:        equ 09h          ; P0.4 Configuration Register              (RW)
 000A           P05CR:        equ 0Ah          ; P0.5 Configuration Register              (RW)
 000B           P06CR:        equ 0Bh          ; P0.6 Configuration Register              (RW)
 000C           P07CR:        equ 0Ch          ; P0.7 Configuration Register              (RW)
 000D           P10CR:        equ 0Dh          ; P1.0 Configuration Register              (RW)
 000E           P11CR:        equ 0Eh          ; P1.1 Configuration Register              (RW)
 000F           P12CR:        equ 0Fh          ; P1.2 Configuration Register              (RW)
 0010           P13CR:        equ 10h          ; P1.3 Configuration Register              (RW)
 0011           P14CR:        equ 11h          ; P1.4 Configuration Register              (RW)
 0012           P15CR:        equ 12h          ; P1.5 Configuration Register              (RW)
 0013           P16CR:        equ 13h          ; P1.6 Configuration Register              (RW)
 0014           P17CR:        equ 14h          ; P1.7 Configuration Register              (RW)
 0015           P2CR:         equ 15h          ; P2.0-P2.7 Configuration Register         (RW)
 0016           P3CR:         equ 16h          ; P3.0-P3.7 Configuration Register         (RW)
 0017           P4CR:         equ 17h          ; P4.0-P4.7 Configuration Register         (RW)
 0000           
 0000           ; Timer Registers
 0020           FRTMRL:       equ 20h          ; Free Running Timer Low                   (RW)
 0021           FRTMRH:       equ 21h          ; Free Running Timer High                  (RW)
 0022           TCAP0R:       equ 22h          ; Capture 0 Rising                         (R)             
 0023           TCAP1R:       equ 23h          ; Capture 1 Rising                         (R)             
 0024           TCAP0F:       equ 24h          ; Capture 0 Falling                        (R)             
 0025           TCAP1F:       equ 25h          ; Capture 1 Falling                        (R)             
 0026           PITMRL:       equ 26h          ; Programmable Interval Timer Low          (RW)
 0027           PITMRH:       equ 27h          ; Programmable Interval Timer High         (RW)
 0028           PIRL:         equ 28h          ; Programmable Interval Timer Reload Low   (RW)
 0029           PIRH:         equ 29h          ; Programmable Interval Timer Reload High  (RW)
 002A           TMRCR:        equ 2Ah          ; Timer Configuration Register             (RW)
 002B           TCAPINTE:     equ 2Bh          ; Capture Timer Interrupt Enable           (RW)
 002C           TCAPINTS:     equ 2Ch          ; Capture Timer Interrupt Status           (RW)
 0000           
 0000           ; Clock Configuration Registers
 0030           CPUCLKCR:     equ 30h          ; CPU Clock Configuration Register         (RW)
 0000           CPUCLK_SEL_INT:         equ 00h ; CPU Clock Select Internal Oscillator
 0001           CPUCLK_SEL_EXT:         equ 01h ; CPU Clock Select External Clock
 0000           CPUCLK_USBCLK_SEL_INT:  equ 00h ; USB Clock Select Internal Clock
 0040           CPUCLK_USBCLK_SEL_EXT:  equ 40h ; USB Clock Select External Clock
 0000           CPUCLK_USBCLK_DIV2_DIS: equ 00h ; USB Clock Divide by 2 disable
 0080           CPUCLK_USBCLK_DIV2_ENA: equ 80h ; USB Clock Divide by 2 enable
 0000           
 0031           TMRCLKCR:     equ 31h          ; Timer Clock Configuration Register       (RW)
 0000           TMRCLKCR_ITMRCLK_IOSC:     equ 00h ; MASK: ITMRCLK Source--Internal Oscillator
 0001           TMRCLKCR_ITMRCLK_XOSC:     equ 01h ; MASK: ITMRCLK Source--External Oscillator or CLKIN
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0003           TMRCLKCR_ITMRCLK_TCAPCLK:  equ 03h ; MASK: ITMRCLK Source--TCAPCLK
 0000           TMRCLKCR_ITMRCLK_DIV_1:    equ 00h ; MASK: ITMRCLK Divider Value 1
 0004           TMRCLKCR_ITMRCLK_DIV_2:    equ 04h ; MASK: ITMRCLK Divider Value 2
 0008           TMRCLKCR_ITMRCLK_DIV_3:    equ 08h ; MASK: ITMRCLK Divider Value 3
 000C           TMRCLKCR_ITMRCLK_DIV_4:    equ 0Ch ; MASK: ITMRCLK Divider Value 4
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0000           TMRCLKCR_TCAPCLK_IOSC:     equ 00h ; MASK: TCAPCLK Source--Internal Oscillator
 0010           TMRCLKCR_TCAPCLK_XOSC:     equ 10h ; MASK: TCAPCLK Source--External Oscillator or CLKIN
 0020           TMRCLKCR_TCAPCLK_LPO:      equ 20h ; MASK: TCAPCLK Source--Low Power Oscillator (32 Khz)
 0030           TMRCLKCR_TCAPCLK_DISABLED: equ 30h ; MASK: TCAPCLK Source--DISABLED
 0000           TMRCLKCR_TCAPCLK_DIV_2:    equ 00h ; MASK: TCAPCLK Divider Value 2
 0040           TMRCLKCR_TCAPCLK_DIV_4:    equ 40h ; MASK: TCAPCLK Divider Value 4
 0080           TMRCLKCR_TCAPCLK_DIV_6:    equ 80h ; MASK: TCAPCLK Divider Value 6
 00C0           TMRCLKCR_TCAPCLK_DIV_8:    equ 0C0h ; MASK: TCAPCLK Divider Value 8
 0000           
 0032           CLKIOCR:      equ 32h          ; Clock I/O Configuration Register         (RW)
 0000           CLKIOCR_CLKOUT_IOSC:       equ 00h ; MASK: Clock Source--Internal Oscillator
 0001           CLKIOCR_CLKOUT_XOSC:       equ 01h ; MASK: Clock Source--External Oscillator or CLKIN
 0002           CLKIOCR_CLKOUT_LPO:        equ 02h ; MASK: Clock Source--Low Power Oscillator (32 Khz)
 0003           CLKIOCR_CLKOUT_CPUCLK:     equ 03h ; MASK: Clock Source--CPUCLK
 0000           
 0000           ; Oscillator Configuration Registers
 0034           IOSCTR:       equ 34h          ; Internal Oscillator Trim Register        (R)
 0035           XOSCTR:       equ 35h          ; Crystal Oscillator Trim Register         (R)
 0036           LPOSCTR:      equ 36h          ; Low Power Oscillator Trim Register       (RW)
 0000           
 0000           ; SPI Configuration/Data Registers
 003C           SPIDATA:      equ 3Ch          ; SPI Data Register                        (RW)
 003D           SPICR:        equ 3Dh          ; SPI Configuration Register               (RW)
 0000           
 0000           ; USB SIE Configuration/Data Registers
 0040           USBCR:        equ 40h          ; USB Configuration Register               (RW)
 0041           EP0CNT:       equ 41h          ; Endpoint 0 Count Register                (RW)
 0042           EP1CNT:       equ 42h          ; Endpoint 1 Count Register                (RW)
 0043           EP2CNT:       equ 43h          ; Endpoint 2 Count Register                (RW)
 0044           EP0MODE:      equ 44h          ; Endpoint 0 Mode  Register                (RW)
 0045           EP1MODE:      equ 45h          ; Endpoint 1 Mode  Register                (RW)
 0046           EP2MODE:      equ 46h          ; Endpoint 2 Mode  Register                (RW)
 0050           EP0DATA:      equ 50h          ; Endpoint 0 Data  Register (50h-57h)      (RW)
 0058           EP1DATA:      equ 58h          ; Endpoint 1 Data  Register (58h-5Fh)      (RW)
 0060           EP2DATA:      equ 60h          ; Endpoint 2 Data  Register (60h-67h)      (RW)
 0000           
 0000           ; Band-gap/TRIMBUF Configuration Registers
 0070           BGAPTR:       equ 70h          ; Band-gap Trim Register                   (R)
 0071           TRIM0:        equ 71h          ; TRIMBUF Trim Register 0                  (R)
 0072           TRIM1:        equ 72h          ; TRIMBUF Trim Register 1                  (R)
 0000           
 0000           ; VREG Configuration Register
 0073           VREGCR:       equ 73h          ; VREG Configuration Register              (RW)
 0000           
 0000           ; USB Transceiver Configuration Registers
 0074           USBXCR:       equ 74h          ; USB Transceiver Configuration Register   (RW)
 0080           USBXCR_ENABLE:    equ 80h      ; USB Transceiver Enable
 0001           USBXCR_FORCE:     equ 01h      ; USB Transceiver Force
 0000           
 0000           ; Data Pointer Registers--Listed for compatability with other M8C based parts.
 00D0           CPPDR:        equ 0D0h          ; Current Page Pointer Data Register       (RW)
 00D4           DPRDR:        equ 0D4h          ; Data Page Read Register                  (RW)
 00D5           DPWDR:        equ 0D5h          ; Data Page Write Register                 (RW)
 0000           
 0000           ; Watchdog Timer Reset
 00E3           RESWDT:       equ 0E3h          ; Watchdog Timer Reset                     (W)
 00E3           RES_WDT:      equ 0E3h          ; WatchDog Timer Register                  (W) (PSoC)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;------------------------------------------------
 00DA           INT_CLR0:     equ 0DAh          ; Interrupt Clear Register 0               (RW)
 0000                                          ; Use INT_MSK0 bit field masks
 00DB           INT_CLR1:     equ 0DBh          ; Interrupt Clear Register 1               (RW)
 0000                                          ; Use INT_MSK1 bit field masks
 00DC           INT_CLR2:     equ 0DCh          ; Interrupt Clear Register 2               (RW)
 0000                                          ; Use INT_MSK2 bit field masks
 0000           
 00DE           INT_MSK3:     equ 0DEh          ; Interrupt Mask Register                  (RW)
 0080           INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
 0000           
 00DF           INT_MSK2:     equ 0DFh          ; Interrupt Mask Register                  (RW)
 0040           INT_MSK2_GPIO_PORT4:       equ 40h ; MASK: enable/disable GPIO Port 4 interrupt
 0020           INT_MSK2_GPIO_PORT3:       equ 20h ; MASK: enable/disable GPIO Port 3 interrupt
 0010           INT_MSK2_GPIO_PORT2:       equ 10h ; MASK: enable/disable GPIO Port 2 interrupt
 0008           INT_MSK2_PS2_DATA_LOW:     equ 08h ; MASK: enable/disable PS/2 Data Low
 0004           INT_MSK2_GPIO_INT2:        equ 04h ; MASK: enable/disable GPIO INT2 interrupt
 0002           INT_MSK2_CTR_16_WRAP:      equ 02h ; MASK: enable/disable 16 bit counter wrap
 0001           INT_MSK2_TCAP1:            equ 01h ; MASK: enable/disable Timer/Capture 0 interrupt
 0000           
 00E0           INT_MSK0:     equ 0E0h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK0_GPIO_PORT1:       equ 80h ; MASK: enable/disable GPIO Port 1 interrupt
 0040           INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO_INT1:        equ 20h ; MASK: enable/disable GPIO INT1 interrupt
 0010           INT_MSK0_GPIO_PORT0:       equ 10h ; MASK: enable/disable GPIO Port 0 interrupt
 0008           INT_MSK0_SPI_RX:           equ 08h ; MASK: enable/disable SPI Receive interrupt
 0004           INT_MSK0_SPI_TX:           equ 04h ; MASK: enable/disable SPI Transmit interrupt
 0002           INT_MSK0_GPIO_INT0:        equ 02h ; MASK: enable/disable GPIO INT0 interrupt
 0001           INT_MSK0_POR_LVD:          equ 01h ; MASK: enable/disable POR/LVD interrupt
 0000           
 00E1           INT_MSK1:     equ 0E1h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK1_TCAP0:            equ 80h ; MASK: enable/disable Timer/Capture 0 interrupt
 0040           INT_MSK1_PIT:              equ 40h ; MASK: enable/disable Progrmmable Interval Timer
 0020           INT_MSK1_MS_TIMER:         equ 20h ; MASK: enable/disable One Millisecond Timer interrupt
 0010           INT_MSK1_USB_ACTIVITY:     equ 10h ; MASK: enable/disable USB Bus Activity interrupt
 0008           INT_MSK1_USB_BUS_RESET:    equ 08h ; MASK: enable/disable USB Bus Reset interrupt
 0004           INT_MSK1_USB_EP2:          equ 04h ; MASK: enable/disable USB Endpoint 2 interrupt
 0002           INT_MSK1_USB_EP1:          equ 02h ; MASK: enable/disable USB Endpoint 1 interrupt
 0001           INT_MSK1_USB_EP0:          equ 01h ; MASK: enable/disable USB Endpoint 0 interrupt
 0000           
 00E2           INT_VC:       equ 0E2h          ; Interrupt vector register                (RC)
 0000           
 0000           ;------------------------------------------------------
 0000           ;        Register bank 1.
 0000           ;------------------------------------------------------
 00E0           OSC_CR0:                   equ 0E0h  ; System Oscillator Control Register 0     (RW)
 0020           OSC_CR0_NO_BUZZ:           equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
 0018           OSC_CR0_SLEEP:             equ 18h    ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_SLEEP_512Hz:       equ 00h    ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_SLEEP_64Hz:        equ 08h    ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_SLEEP_8Hz:         equ 10h    ;     Set sleep bits for 125ms period
 0018           OSC_CR0_SLEEP_1Hz:         equ 18h    ;     Set sleep bits for 1 sec period
 0000           
 0007           OSC_CR0_CPU:               equ 07h    ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:          equ 00h    ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:          equ 01h    ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:         equ 02h    ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:         equ 03h    ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:        equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:        equ 05h    ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz:      equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
 0000           
 0000           ;------------------------------------------------------
 0000           ;  Note: The following registers are mapped into both
 0000           ;        register bank 0 AND register bank 1.
 0000           ;------------------------------------------------------
 00F7           CPU_F:        equ 0F7h          ; CPU Flag Register Access                 (RO)
 0000                                              ; Use FLAG_ masks defined at top of file
 00FF           CPU_SCR:     equ 0FFh          ; CPU Status and Control Register          (#)
 0080           CPU_SCR_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
 0020           CPU_SCR_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
 0010           CPU_SCR_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
 0008           CPU_SCR_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
 0001           CPU_SCR_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 1
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Clock and System Control Registers
 0000           ;------------------------------------------------
 0000           
 0000           ;;=============================================================================
 0000           ;;      M8C System Macros
 0000           ;;  These macros should be used when their functions are needed.
 0000           ;;=============================================================================
 0000           
 0000           ;----------------------------------------------------
 0000           ;  Swapping Register Banks
 0000           ;----------------------------------------------------
 0000               macro M8C_SetBank0
 0000               and   F, ~FLAG_XIO_MASK
 0000               macro M8C_SetBank1
 0000               or    F, FLAG_XIO_MASK
 0000               macro M8C_EnableGInt
 0000               or    F, FLAG_GLOBAL_IE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FLAG_GLOBAL_IE
 0000               macro M8C_DisableIntMask
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000               macro M8C_EnableIntMask
 0000               or    reg[@0], @1               ; enable specified interrupt enable bit
 0000               macro M8C_ClearIntFlag
 0000               mov   reg[@0], ~@1              ; clear specified interrupt enable bit
 0000               macro M8C_EnableWatchDog
 0000               and   reg[CPU_SCR], ~CPU_SCR_PORS_MASK
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR], CPU_SCR_SLEEP_MASK
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then the CPU sleeps forever.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR], CPU_SCR_STOP_MASK
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore CPU to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro Suspend_CodeCompressor
 0000               or   F, 0
 0000               macro Resume_CodeCompressor
 0000               add  SP, 0
 0000           MACRO   GET_WORD
 0000               PUSH A                              ; Quickly get a RAM temp
 0000               PUSH A                              ; Save the source MSB
 0000               ROMX                                ; Get the first byte
 0000               PUSH X                              ; Save X
 0000               MOV  X,SP                           ; Get SP, to index to the temp 
 0000               MOV  [X - 3],A                      ; Save the first byte
 0000               POP  X                              ; Get back the source LSB
 0000               POP  A                              ; And the MSB
 0000               INC  X                              ; Point to the second byte
 0000               ADC  A, 0                           ; 
 0000               ROMX                                ; Get the second byte
 0000               MOV  X,A                            ; Save it in X
 0000               POP  A                              ; And the first byte in A
 0000           MACRO   NULL_PTR_CHECK
 0000               SWAP    A, X                        ; LSB non-zero?
 0000               JNZ     .ok                         ; Exit on non-zero
 0000               SWAP    A, X                        ; MSB zero
 0000               JZ      @0                          ; Jump to the null pointer handler
 0000               JMP     .exit
 0000           .ok:
 0000               SWAP    A, X                        ; Put them back
 0000           .exit:
 0000           NULL_PTR:   EQU 0                       ; Null pointer value
 0000           
 0000           ;--------------------------------------------------
 0000           ; TRANSFER DESCRIPTOR MACROS
 0000           ;--------------------------------------------------
 0000           
 0000           ;-----------------------------------------------
 0000           ; TD_START_TABLE MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = Number of table entries
 0000           ; Register setup
 0000           ;   N/A (builds ROM data at assembly time)
 0000           ;-----------------------------------------------
 0000           MACRO   TD_START_TABLE
 0000               DB      ((@0) - 1)                 ; Number of table entries - 1
 0000           MACRO   TD_ENTRY
 0000               DB  @0                             ; Data source (USB_DS_*)
 0000               DW  @1                             ; Transfer size
 0000               DW  @2                             ; Data source address
 0000               DW  @3                             ; Transfer Completion Status Block Address
 0000               DB  0xde                           ; Reserved 
 0008           TD_ENTRY_SIZE:                         EQU 8
 0001           TD_START_SIZE:                         EQU 1
 0000           ;-----------------------------------------------
 0000           ; TD_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (restored)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   TD_INDEX_TO_OFFSET
 0000               PUSH    A                          ; Save a work register
 0000               ASL     [@0]                       ; Index * 2
 0000               ASL     [@0]                       ; Index * 4
 0000               ASL     [@0]                       ; Index * 4
 0000               POP     A                          ; Restore the work register
 0000           MACRO LT_START
 0000               DB      (@0)                       ; Table size
 0000           MACRO LT_ENTRY
 0000               DW      (@0)                       ; Table entry
 0000               DW      (@1)                       ; Table entry
 0002           LT_ENTRY_SIZE:                         EQU 2
 0001           LT_START_SIZE:                         EQU 1
 0000           
 0000           ;-----------------------------------------------
 0000           ; LT_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (not used)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   LT_INDEX_TO_OFFSET
 0000               ASL     [@0]                       ; Simply shift (mult by 2)
 0000               ASL     [@0]                       ;              (mult by 4)
 0000           MACRO DISPATCHER
 0000               CMP   A,@1
 0000               JNC   .dispatch_not_supported
 0000               ASL   A
 0000               JACC  @0
 0000           .dispatch_not_supported:
 0000               JMP  @2    
 0002           USB_bNumStringDescrs: EQU    2
 0000           
 0003           USB_NUM_ENDPOINTS:                          EQU 3 
 0002           USB_MAX_EP_NUMBER:                          EQU (USB_NUM_ENDPOINTS - 1) 
 0000           
 0000           ;--------------------------------------------------
 0000           ; Registers for USB API's.
 0000           ;--------------------------------------------------
 0074           USB_USBXCR:    EQU    USBXCR
 0040           USB_ADDR:      EQU    USBCR
 0041           USB_EP0CNT:    EQU    EP0CNT
 0042           USB_EP1CNT:    EQU    (EP0CNT + 1)
 0043           USB_EP2CNT:    EQU    (EP0CNT + 2)
 0044           USB_EP0MODE:   EQU    EP0MODE
 0045           USB_EP1MODE:   EQU    (EP0MODE + 1)
 0046           USB_EP2MODE:   EQU    (EP0MODE + 2)
 0050           USB_EP0DATA:   EQU    EP0DATA
 0058           USB_EP1DATA:   EQU    (EP0DATA + 8)
 0060           USB_EP2DATA:   EQU    (EP0DATA + 16)
 0000           
 0000           ;--------------------------------------------------
 0000           ; Endpoint 0 offsets (Table 9-2)
 0000           ;--------------------------------------------------
 0000           bmRequestType:                              EQU     0
 0001           bRequest:                                   EQU     1
 0002           wValue:                                     EQU     2
 0003           wValueHi:                                   EQU     3
 0002           wValueLo:                                   EQU     2
 0004           wIndex:                                     EQU     4
 0005           wIndexHi:                                   EQU     5
 0004           wIndexLo:                                   EQU     4
 0006           wLength:                                    EQU     6
 0007           wLengthHi:                                  EQU     7
 0006           wLengthLo:                                  EQU     6
 0000           
 0000           ;--------------------------------------------------
 0000           ; Request Types (Table 9-4)
 0000           ;--------------------------------------------------
 0000           USB_GET_STATUS:                             EQU    0x00
 0001           USB_CLEAR_FEATURE:                          EQU    0x01
 0003           USB_SET_FEATURE:                            EQU    0x03
 0005           USB_SET_ADDRESS:                            EQU    0x05
 0006           USB_GET_DESCRIPTOR:                         EQU    0x06
 0007           USB_SET_DESCRIPTOR:                         EQU    0x07
 0008           USB_GET_CONFIGURATION:                      EQU    0x08
 0009           USB_SET_CONFIGURATION:                      EQU    0x09
 000A           USB_GET_INTERFACE:                          EQU    0x0A
 000B           USB_SET_INTERFACE:                          EQU    0x0B
 000C           USB_SYNCH_FRAME:                            EQU    0x0C
 0000           
 0000           ;--------------------------------------------------
 0000           ; Descriptor Types (Table 9-5)
 0000           ;--------------------------------------------------
 0001           DESCR_TYPE_DEVICE:                          EQU     1
 0002           DESCR_TYPE_CONFIG:                          EQU     2
 0003           DESCR_TYPE_STRING:                          EQU     3
 0004           DESCR_TYPE_INTERFACE:                       EQU     4
 0005           DESCR_TYPE_ENDPOINT:                        EQU     5
 0006           DESCR_TYPE_DEVICE_QUALIFIER:                EQU     6
 0007           DESCR_TYPE_OTHER_SPEED:                     EQU     7
 0008           DESCR_TYPE_INTERFACE_POWER:                 EQU     8
 0000           
 0000           ;--------------------------------------------------
 0000           ; Feature Selectors (Table 9-6)
 0000           ;--------------------------------------------------
 0001           USB_DEVICE_REMOTE_WAKEUP:                   EQU    0x01
 0000           USB_ENDPOINT_HALT:                          EQU    0x00
 0002           USB_TEST_MODE:                              EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Device Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0000           USB_DEVICE_STATUS_BUS_POWERED:              EQU   0x00
 0001           USB_DEVICE_STATUS_SELF_POWERED:             EQU   0x01
 0002           USB_DEVICE_STATUS_REMOTE_WAKEUP:            EQU   0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0001           USB_ENDPOINT_STATUS_HALT:                   EQU    0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Directions
 0000           ;--------------------------------------------------
 0080           USB_DIR_IN:                                 EQU    0x80
 0000           USB_DIR_OUT:                                EQU    0x00
 007F           USB_DIR_UNUSED:                             EQU    0x7F
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Address Symbols 
 0000           ;--------------------------------------------------
 0000           EP0:                                        EQU    0x00
 0001           EP1:                                        EQU    0x01
 0002           EP2:                                        EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Endpoint States--These act as JACC jump values
 0000           ;--------------------------------------------------
 0000           USB_TRANS_STATE_IDLE:                       EQU     0x00         ;
 0002           USB_TRANS_STATE_CONTROL_READ:               EQU     0x02         ;
 0004           USB_TRANS_STATE_CONTROL_WRITE:              EQU     0x04         ;
 0006           USB_TRANS_STATE_NO_DATA_CONTROL:            EQU     0x06         ;
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Write flag values to indicate pending data changes
 0000           ;--------------------------------------------------
 0001           USB_ADDRESS_CHANGE_PENDING:     EQU     0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; Register Constants for USB
 0000           ;--------------------------------------------------
 0080           USB_ADDR_ENABLE:                             EQU 0x80
 0040           USB_CNT_VALID:                               EQU 0x40
 0080           USB_CNT_TOGGLE:                              EQU 0x80
 0080           USB_PULLUP_ENABLE:                           EQU 0x80
 0000           
 0000           
 0000           USB_MODE_DISABLE:                            EQU 0x00
 0001           USB_MODE_NAK_IN_OUT:                         EQU 0x01
 0002           USB_MODE_STATUS_OUT_ONLY:                    EQU 0x02
 0003           USB_MODE_STALL_IN_OUT:                       EQU 0x03
 0004           USB_MODE_RESERVED_0100:                      EQU 0x04
 0005           USB_MODE_ISO_OUT:                            EQU 0x05
 0006           USB_MODE_STATUS_IN_ONLY:                     EQU 0x06
 0007           USB_MODE_ISO_IN:                             EQU 0x07
 0008           USB_MODE_NAK_OUT:                            EQU 0x08
 0009           USB_MODE_ACK_OUT:                            EQU 0x09
 000A           USB_MODE_RESERVED_1010:                      EQU 0x0A
 000B           USB_MODE_ACK_OUT_STATUS_IN:                  EQU 0x0B
 000C           USB_MODE_NAK_IN:                             EQU 0x0C
 000D           USB_MODE_ACK_IN:                             EQU 0x0D
 000E           USB_MODE_RESERVED_1110:                      EQU 0x0E
 000F           USB_MODE_ACK_IN_STATUS_OUT:                  EQU 0x0F
 0080           USB_MODE_STALL_DATA_EP:                      EQU 0x80
 0000           
 0000           ;--------------------------------------------------
 0000           ; FORCE J/K/SE0 (Argument values)
 0000           ;--------------------------------------------------
 0002           USB_FORCE_J:                                 EQU 0x02
 0001           USB_FORCE_K:                                 EQU 0x01
 0000           USB_FORCE_SE0:                               EQU 0x00
 00FF           USB_FORCE_NONE:                              EQU 0xFF
 0001           USB_FORCE_STATE:                             EQU 0x01
 0000           
 0000           ;-----------------------------------------------
 0000           ; Endpoint event flags
 0000           ;-----------------------------------------------
 0002           NO_EVENT_ALLOWED:	equ               2
 0001           EVENT_PENDING:      equ               1
 0000           NO_EVENT_PENDING:   equ               0
 0000           
 0000           IN_BUFFER_FULL:     equ               NO_EVENT_PENDING
 0001           IN_BUFFER_EMPTY:    equ               EVENT_PENDING
 0001           OUT_BUFFER_FULL:    equ               EVENT_PENDING
 0000           OUT_BUFFER_EMPTY:   equ               NO_EVENT_PENDING
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Request Dispatch Functions, including overrides
 0000           ;--------------------------------------------------
 0001           USB_NOT_SUPPORTED:  EQU 0x01
 0002           USB_UM_SUPPLIED:    EQU 0x02
 0004           USB_APP_SUPPLIED:   EQU 0x04
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_dev_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_05: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_06: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_07: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_08: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_dev_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_03: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_04: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_05: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_08: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_09: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ifc_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_ifc_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_05: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_08: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_09: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_ifc_10: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ifc_00: equ USB_NOT_SUPPORTED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ep_00: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ep_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_ep_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_03: equ USB_UM_SUPPLIED
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Standard Requests
 0000           ;-----------------------------------------------
 0001           USB_CB_h2d_std_dev: equ 1
 0001           USB_CB_h2d_std_ifc: equ 1
 0001           USB_CB_h2d_std_ep:  equ 1
 0000           USB_CB_h2d_std_oth: equ 0
 0001           USB_CB_d2h_std_dev: equ 1
 0001           USB_CB_d2h_std_ifc: equ 1
 0001           USB_CB_d2h_std_ep:  equ 1
 0000           USB_CB_d2h_std_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Class Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_cls_dev: equ 0
 0000           USB_CB_h2d_cls_ifc: equ 0
 0000           USB_CB_h2d_cls_ep:  equ 0
 0000           USB_CB_h2d_cls_oth: equ 0
 0000           USB_CB_d2h_cls_dev: equ 0
 0000           USB_CB_d2h_cls_ifc: equ 0
 0000           USB_CB_d2h_cls_ep:  equ 0
 0000           USB_CB_d2h_cls_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_vnd_dev: equ 0
 0000           USB_CB_h2d_vnd_ifc: equ 0
 0000           USB_CB_h2d_vnd_ep:  equ 0
 0000           USB_CB_h2d_vnd_oth: equ 0
 0000           USB_CB_d2h_vnd_dev: equ 0
 0000           USB_CB_d2h_vnd_ifc: equ 0
 0000           USB_CB_d2h_vnd_ep:  equ 0
 0000           USB_CB_d2h_vnd_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Reserved Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_rsv_dev: equ 0
 0000           USB_CB_h2d_rsv_ifc: equ 0
 0000           USB_CB_h2d_rsv_ep:  equ 0
 0000           USB_CB_h2d_rsv_oth: equ 0
 0000           USB_CB_d2h_rsv_dev: equ 0
 0000           USB_CB_d2h_rsv_ifc: equ 0
 0000           USB_CB_d2h_rsv_ep:  equ 0
 0000           USB_CB_d2h_rsv_oth: equ 0
 0000           
 0000           ;--------------------------------------------------
 0000           ; Transfer Descriptor--Data Source
 0000           ;--------------------------------------------------
 0000           USB_DS_ROM:                                      EQU 0x00
 0001           USB_DS_RAM:                                      EQU 0x01
 0002           USB_DS_RAM_CB:                                   EQU 0x02
 0003           USB_DS_RAM_MASK:                                 EQU 0x03
 0000           
 0000           ;-----------------------------------------------
 0000           ; Transfer Completion Notification
 0000           ;-----------------------------------------------
 0000           USB_XFER_IDLE:         equ      0x00
 0001           USB_XFER_STATUS_ACK:   equ      0x01
 0002           USB_XFER_PREMATURE:    equ      0x02
 0003           USB_XFER_ERROR:        equ      0x03
 0000           
 0000           ; This macro is used to allocate a completion status block
 0000           ; for all Requests.  The macro parameter is used
 0000           ; to prefix the two data elements.
 0000           USB_XFER_STATUS:       equ      0
 0001           USB_XFER_LENGTH:       equ      1
 0000           MACRO    USB_XFER_STATUS_BLOCK
 0000               BLK    1    ; Completion Status
 0000               BLK    2    ; Transfer Length
 0000           USB_CLASS_NONE:                        EQU    0x00
 0001           USB_CLASS_HID:                         EQU    0x01
 0000           USB_CLASS:                             EQU    USB_CLASS_NONE
 0000           
 0000           ;-----------------------------------------------
 0000           ; Modify the supported requests by redefining
 0000           ; them within the custom code area below
 0000           ;-----------------------------------------------
 0000           
 0000              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code below this banner
 0000              ;---------------------------------------------------
 0000              ;   NOTE: interrupt service routines must preserve
 0000              ;   the values of the A and X CPU registers.
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code above this banner
 0000              ;---------------------------------------------------
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function below this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              
 0000              ;PRESERVE_CPU_CONTEXT
 0000              ;lcall _My_C_Function
 0000              ;RESTORE_CPU_CONTEXT
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function above this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              ;@PSoC_UserCode_END@ (Do not change this line.)
 0000           ;-----------------------------------------------
 0000           ; Has the user enabled any of the Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_VSR_SUPPORT: EQU 0
                IF USB_CB_h2d_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                
                ; end of file USB.inc
                
                ;-----------------------------------------------
                ;  Global Symbols
                ;-----------------------------------------------
                
                AREA bss (RAM,REL)
                
                ;-----------------------------------------------
                ;  Constant Definitions
                ;-----------------------------------------------
                ;-----------------------------------------------
                ; Variable Allocation
                ;-----------------------------------------------
                
                AREA UserModules (ROM, REL)
                
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_Not_Supported
                ;
                ;  DESCRIPTION:   The USB_Not_Supported routine is invoked for any
                ;         USB request that is not supported.  It is invoked with a
                ;         JMP/LJMP and does not return.  It exits through the common
                ;                 EP0 exit.
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:     None
                ;
                ;  RETURNS:       Does not return
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                
                ; d2h_std_dev
                IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_00
                USB_CB_d2h_std_dev_00:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_01
 0000           USB_CB_d2h_std_dev_01:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_02
 0000           USB_CB_d2h_std_dev_02:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_03
 0000           USB_CB_d2h_std_dev_03:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_04
 0000           USB_CB_d2h_std_dev_04:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_05
 0000           USB_CB_d2h_std_dev_05:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_06
                USB_CB_d2h_std_dev_06:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_07
 0000           USB_CB_d2h_std_dev_07:
                ENDIF
                IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_dev_08
                USB_CB_d2h_std_dev_08:
                ENDIF
                
                ; h2d_std_dev
                IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_00
 0000           USB_CB_h2d_std_dev_00:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_01
                USB_CB_h2d_std_dev_01:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_02
 0000           USB_CB_h2d_std_dev_02:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_03
                USB_CB_h2d_std_dev_03:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_04
 0000           USB_CB_h2d_std_dev_04:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_05
                USB_CB_h2d_std_dev_05:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_06
 0000           USB_CB_h2d_std_dev_06:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_07
 0000           USB_CB_h2d_std_dev_07:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_08
 0000           USB_CB_h2d_std_dev_08:
                ENDIF
                IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_dev_09
                USB_CB_h2d_std_dev_09:
                ENDIF
                
                ; d2h_std_ifc
                IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_00
                USB_CB_d2h_std_ifc_00:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_01
 0000           USB_CB_d2h_std_ifc_01:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_02
 0000           USB_CB_d2h_std_ifc_02:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_03
 0000           USB_CB_d2h_std_ifc_03:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_04
 0000           USB_CB_d2h_std_ifc_04:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_05
 0000           USB_CB_d2h_std_ifc_05:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_06
 0000           USB_CB_d2h_std_ifc_06:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_07
 0000           USB_CB_d2h_std_ifc_07:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_08
 0000           USB_CB_d2h_std_ifc_08:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_09
 0000           USB_CB_d2h_std_ifc_09:
                ENDIF
                IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ifc_10
                USB_CB_d2h_std_ifc_10:
                ENDIF
                
                ; d2h_std_ifc
                IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_ifc_00
 0000           USB_CB_h2d_std_ifc_00:
                ENDIF
                
                ; d2h_std_ep
                IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                export  USB_CB_d2h_std_ep_00
                USB_CB_d2h_std_ep_00:
                ENDIF
                
                ; h2d_std_ep
                IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_ep_00
 0000           USB_CB_h2d_std_ep_00:
                ENDIF
                IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_ep_01
                USB_CB_h2d_std_ep_01:
                ENDIF
                IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_ep_02
 0000           USB_CB_h2d_std_ep_02:
                ENDIF
                IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                export  USB_CB_h2d_std_ep_03
                USB_CB_h2d_std_ep_03:
                ENDIF
                
                export  USB_Not_Supported
                export _USB_Not_Supported
 0000           USB_Not_Supported:
 0000           _USB_Not_Supported:
 0000 5000         MOV    A, 0                         ; Count 0
 0002 5703         MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
 0004 7D0000       LJMP   USB_EP0_UPD_MODE_EXIT
 0007           ;-----------------------------------------------------------------------------
 0007           ;  FUNCTION NAME: USB_CB_d2h_std_dev_00
 0007           ;
 0007           ;  DESCRIPTION:   Get Device Status
 0007           ;
 0007           ;****************************************************************
 0007           ; STANDARD DEVICE IN REQUEST: Get_Device_Status
 0007           ;****************************************************************
 0007           ;
 0007           ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h     
 0007           ; bRequest       : GET_STATUS                     = 00h    
 0007           ; wValue         : RESERVED                       = 0000h  
 0007           ; wIndex         : RESERVED                       = 0000h
 0007           ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
 0007           ; 
 0007           ; The GET_DEVICE_STATUS request returns the current device status.
 0007           ;
 0007           ;****************************************************************
 0007           ;-----------------------------------------------------------------------------
 0007           ;
 0007           ;  ARGUMENTS:
 0007           ;
 0007           ;  RETURNS:
 0007           ;
 0007           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0007           ;
 0007           ;  THEORY of OPERATION or PROCEDURE:
 0007           ;
 0007           ;-----------------------------------------------------------------------------
 0007           .LITERAL
 0007           GetStatusTransferDescrTable:
 0007 00            DB      ((1) - 1)                 ; Number of table entries - 1
 0008 01            DB  USB_DS_RAM                             ; Data source (USB_DS_*)
 0009 0002          DW  2                             ; Transfer size
 000B 0000          DW  USB_TransferBuffer                             ; Data source address
 000D 0000          DW  NULL_PTR                             ; Transfer Completion Status Block Address
 000F DE            DB  0xde                           ; Reserved 
 0010           .ENDLITERAL
                IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                export  USB_CB_d2h_std_dev_00
 0010           USB_CB_d2h_std_dev_00:
 0010 550000        MOV     [USB_t2], 0                ; Use the UM temp var--Selector
 0013           
 0013 550100        MOV     [USB_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
 0016 5F0000        MOV     [USB_TransferBuffer], [USB_DeviceStatus]
 0019           
 0019 5007          MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
 001B 5707          MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
 001D 8267          JMP     USB_GetTableEntry_Local_Std
                ELSE
                IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_dev_00
                USB_CB_d2h_std_dev_00:
                    LJMP    APP_USB_CB_d2h_std_dev_00
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ; FUNCTION NAME: USB_CB_d2h_std_dev_06
                ;
                ; DESCRIPTION:   Get Device Descriptor
                ;
                ;****************************************************************
                ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                ;****************************************************************
                ;
                ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                ; bRequest       : GET_DESCRIPTOR                 = 06h    
                ; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh  
                ; wIndex         : ZERO or LANG_ID                = xxxxh
                ; wLength        : SIZEOF_DESCRIPTOR              = --xxh  
                ; 
                ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if 
                ; the descriptor exists. 
                ; 
                ; The upper byte of wValue contains the descriptor type and 
                ; the lower byte contains the descriptor index. wIndex 
                ; contains either 0000h or the Language ID. wLength contains 
                ; the descriptor length. The actual descriptor information is 
                ; transferred in subsequent data packets. 
                ;
                ;****************************************************************
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                export  USB_CB_d2h_std_dev_06
 001F           USB_CB_d2h_std_dev_06:
 001F           ;-----------------------------------------------------------------------------
 001F           ; Dispatch to the proper handler
 001F           ;-----------------------------------------------------------------------------
 001F 5D53          MOV     A, REG[USB_EP0DATA+wValueHi] ; Get the descrptor type
 0021 64            ASL     A                          ; Make it into a offset
 0022 3908          CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
 0024 DFDB          JNC     USB_Not_Supported
 0026           
 0026 E001          JACC    GET_DESCR_DISPATCH
 0028           
 0028           GET_DESCR_DISPATCH:
 0028 8FD7          JMP     USB_Not_Supported          ; Invalid
 002A 8028          JMP     USB_SendDeviceDescr        ; Device Descriptor
 002C 8003          JMP     USB_SendConfigDescr        ; Configuration Descriptor
                IF  USB_bNumStringDescrs               ; Number of String Descriptor defined with the Wizard
 002E 8034          JMP     USB_SendStringDescr        ; String Descriptor
                ELSE
                    JMP     USB_Not_Supported          ; Not supported if we don't have
                                                            ; any String Descriptor
                ENDIF
 0030           GET_DESCR_DISPATCH_END:
 0008           GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)     
 0030           ;-----------------------------------------------------------------------------
 0030           ; Configuration Descriptor Handler
 0030           ;-----------------------------------------------------------------------------
 0030           USB_SendConfigDescr:
 0030 9000          CALL    USB_GET_DEVICE_TABLE_ENTRY
 0032 4B            SWAP    A, X
 0033 0102          ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
 0035 4B            SWAP    A, X
 0036 0900          ADC     A, 0                       ; Don't forget the carry
 0038 550000        MOV    [USB_t2], USB_t1            ; Set up the destination  
 003B 9000          CALL    USB_GETWORD                ; Get the pointer
 003D               
 003D 5100          MOV     A, [USB_t1]                ; Pointer MSB
 003F 5801          MOV     X, [USB_t1+1]              ; Pointer LSB
 0041               
 0041 08            PUSH    A                          ; Save the MSB
 0042               
 0042 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the descrptor index
 0044 5300          MOV     [USB_t2], A                ; Use the UM temp var--Selector
 0046 18            POP     A                          ; Need the MSB for the range check
 0047 08            PUSH    A                          ; Save the MSB for after the range check
 0048 28            ROMX                               ; First entry is the table size (only a byte)
 0049 3A00          CMP     A, [USB_t2]                ; Range check
 004B D004          JNC     .range_ok
 004D               
 004D 18            POP     A                          ; Fix the stack
 004E 8FB1          JMP    USB_Not_Supported
 0050           
 0050           .range_ok:
 0050 18            POP     A                          ; Get the MSB back
 0051 8233          JMP     USB_GetTableEntry_Local_Std
 0053           ;-----------------------------------------------------------------------------
 0053           ; Device Descriptor Handler
 0053           ;-----------------------------------------------------------------------------
 0053           USB_SendDeviceDescr:
 0053 5F0000        MOV     [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
 0056 5000          MOV     A,>USB_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
 0058 5700          MOV     X,<USB_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
 005A 28            ROMX                               ; First entry is the table size (only a byte)
 005B 3A00          CMP     A, [USB_t2]                ; Range check
 005D CFA2          JC      USB_Not_Supported
 005F           
 005F 5000          MOV     A,>USB_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
 0061           
 0061 8223          JMP     USB_GetTableEntry_Local_Std
 0063           ;-----------------------------------------------------------------------------
 0063           ; String Descriptor Handler
 0063           ;-----------------------------------------------------------------------------
                IF  USB_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
 0063           USB_SendStringDescr:
 0063 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the descrptor index
 0065 5300          MOV     [USB_t2], A                ; Use the UM temp var--Selector
 0067           
 0067 5000          MOV     A,>USB_StringTable         ; Get the ROM Address MSB
 0069 5700          MOV     X,<USB_StringTable         ; Get the ROM Address LSB
 006B 28            ROMX                               ; First entry is the table size (only a byte)
 006C 3A00          CMP     A, [USB_t2]                ; Range check
 006E CF91          JC      USB_Not_Supported
 0070           
 0070 5000          MOV     A,>USB_StringTable         ; Get the ROM Address MSB
 0072           
 0072 8212          JMP     USB_GetTableEntry_Local_Std
                ENDIF
                ELSE
                IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_dev_06
                USB_CB_d2h_std_dev_06:
                    LJMP    APP_USB_CB_d2h_std_dev_06
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_d2h_std_dev_08
                ;
                ;  DESCRIPTION:   Get Device Configuration
                ;
                ;****************************************************************
                ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                ;****************************************************************
                ;
                ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                ; bRequest       : GET_CONFIGURATION              = 08h    
                ; wValue         : RESERVED                       = 0000h  
                ; wIndex         : RESERVED                       = 0000h
                ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h  
                ; 
                ; The GET_DEVICE_CONFIGURATION request returns the currently 
                ; selected device configuration number. 
                ;
                ; request_value and request_index contain 0000h. request_length 
                ; contains 0001h and the one-byte configuration number is returned 
                ; in a separate data transfer.
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
 0074           .LITERAL
 0074           GetConfigTransferDescrTable:
 0074 00            DB      ((1) - 1)                 ; Number of table entries - 1
 0075 01            DB  USB_DS_RAM                             ; Data source (USB_DS_*)
 0076 0001          DW  1                             ; Transfer size
 0078 0000          DW  USB_Configuration                             ; Data source address
 007A 0000          DW  NULL_PTR                             ; Transfer Completion Status Block Address
 007C DE            DB  0xde                           ; Reserved 
 007D           .ENDLITERAL
                export  USB_CB_d2h_std_dev_08
 007D           USB_CB_d2h_std_dev_08:
 007D 550000        MOV     [USB_t2], 0                ; Use the UM temp var--Selector
 0080 5074          MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
 0082 5774          MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
 0084 8200          JMP     USB_GetTableEntry_Local_Std
                ELSE
                IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_dev_08
                USB_CB_d2h_std_dev_08:
                    LJMP    APP_USB_CB_d2h_std_dev_08
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_dev_01
                ;
                ;  DESCRIPTION:   Clear Device Feature
                ;
                ;****************************************************************
                ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                ; bRequest       : CLEAR_FEATURE                  = 01h    
                ; wValue         : FEATURE_SELECTOR               = --xxh  
                ; wIndex         : RESERVED                       = 0000h
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The CLEAR_DEVICE_FEATURE request disables a particular feature 
                ; for a device. The only feature supported for a device is the 
                ; REMOTE_WAKEUP feature.
                ; 
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_dev_01
 0086           USB_CB_h2d_std_dev_01:
 0086 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the Feature Selector
 0088                                                  ; Check against valid features
 0088                                                  ;  for device receipient
 0088 3901          CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
 008A BF75          JNZ     USB_Not_Supported          ;      
 008C 2600FD        AND     [USB_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
 008F 81F8          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_dev_01
                USB_CB_h2d_std_dev_01:
                    LJMP    APP_USB_CB_h2d_std_dev_01
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_dev_03
                ;
                ;  DESCRIPTION:   Set Device Featue
                ;
                ;****************************************************************
                ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                ; bRequest       : SET_FEATURE                    = 03h    
                ; wValue         : FEATURE_SELECTOR               = --xxh  
                ; wIndex         : RESERVED                       = 0000h
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The SET_DEVICE_FEATURE request enables a particular feature
                ; on a device. The only feature supported for a device is the 
                ; REMOTE_WAKEUP feature.
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_dev_03
 0091           USB_CB_h2d_std_dev_03:
 0091 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the Feature Selector
 0093                                                  ; Check against valid features
 0093                                                  ;  for device receipient
 0093 3901          CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
 0095 A007          JZ      .remote_wakeup
 0097           
 0097 3902          CMP     A, USB_TEST_MODE           ; Test Mode 
 0099 A008          JZ      .test_mode
 009B           ; Flow here for any other selector is invalid for device receipient
 009B 8F64          JMP     USB_Not_Supported
 009D           ; Jump here to enable remote wake up
 009D           .remote_wakeup:
 009D 2E0002        OR      [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
 00A0 8003          JMP     .finish
 00A2           ; Jump here to enable test mode
 00A2           .test_mode:
 00A2 8F5D          JMP     USB_Not_Supported
 00A4           .finish:
 00A4 81E3          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_dev_03
                USB_CB_h2d_std_dev_03:
                    LJMP    APP_USB_CB_h2d_std_dev_03
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_dev_05
                ;
                ;  DESCRIPTION:   Set Device Address
                ;
                ;****************************************************************
                ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                ; bRequest       : SET_ADDRESS                    = 05h    
                ; wValue         : DEVICE_ADDRESS                 = 00xxh  
                ; wIndex         : RESERVED                       = 0000h
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The SET_DEVICE_ADDRESS request sets the USB device address
                ; for all future USB accesses. 
                ;
                ;****************************************************************
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                
                IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_dev_05
 00A6           USB_CB_h2d_std_dev_05:
 00A6                 
 00A6 550001        MOV     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING       
 00A9 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]       
 00AB 5300          MOV     [USB_TransferBuffer],A       
 00AD                                                              
 00AD 81DA          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_dev_05
                USB_CB_h2d_std_dev_05:
                    LJMP    APP_USB_CB_h2d_std_dev_05
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_dev_09
                ;
                ;  DESCRIPTION:   Set Configuration
                ;
                ;****************************************************************
                ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                ; bRequest       : SET_CONFIGURATION              = 09h    
                ; wValue         : CONFIGURATION_VALUE            = --xxh  
                ; wIndex         : RESERVED                       = 0000h
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The SET_DEVICE_CONFIGURATION request selects a device 
                ; configuration to be activated as the current configuration. 
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_dev_09
 00AF           USB_CB_h2d_std_dev_09:
 00AF 9000          CALL    USB_GET_DEVICE_TABLE_ENTRY ; Get the selected device
 00B1 550000        MOV     [USB_t2],USB_t1            ; Set the GETWORD destination 
 00B4 9000          CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
 00B6                                                  ; ITempW has the address
 00B6 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the configuration number
 00B8 5300          MOV     [USB_t2],A                 ; Save it 
 00BA 5100          MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
 00BC 5801          MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
 00BE 28            ROMX                               ; First entry is the table size (only a byte)
 00BF 3A00          CMP     A, [USB_t2]                ; Range check
 00C1 CF3E          JC      USB_Not_Supported
 00C3           
 00C3           ; Refactored from the two loops below
 00C3 5F0000        MOV     [USB_Configuration],[USB_t2]  ; Save the config number
 00C6           
 00C6 3C0000        CMP     [USB_t2], 0                ; Unconfigure?
 00C9 A025          JZ      .unconfigure
 00CB           
 00CB           ; Flow here to configure the endpoints
 00CB 5100          MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
 00CD 5801          MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
 00CF 75            INC     X                          ; Point to the first table entry
 00D0 0900          ADC     A, 0                       ;
 00D2 550000        MOV    [USB_t2], USB_t1            ; Set up the destination  
 00D5 9000          CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
 00D7                                                  ; ITempW has the address
 00D7 5700          MOV     X, 0                       ; Start the index at 0, but we INC first
 00D9           .configure_next:
 00D9 75            INC     X                          ; Do the next one
 00DA 10            PUSH    X                          ; Save the endpoint number
 00DB 5100          MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
 00DD 5801          MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
 00DF 28            ROMX
 00E0 7601          INC     [USB_t1+1]                 ; Point to the next 
 00E2 0E0000        ADC     [USB_t1], 0                ;
 00E5 20            POP     X
 00E6 90AC          CALL    ConfigureEP                ; X contains the EP number
 00E8                                                  ; A contains the EP Direction
 00E8 5B            MOV     A, X                       ; 
 00E9 3902          CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
 00EB BFED          JNZ     .configure_next            ; Do another one?
 00ED           ; Flow here when we are done
 00ED 800C          JMP     .done
 00EF           
 00EF           ; Jump here to unconfigure the endpoints
 00EF           .unconfigure:
 00EF 5702          MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
 00F1           .unconfigure_next:
 00F1 560002        MOV     [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
 00F4 634400        MOV     REG[X+EP0MODE], USB_MODE_DISABLE ; Disable the endpoint
 00F7 79            DEC     X                          ; One more down
 00F8 BFF8          JNZ     .unconfigure_next          ; Don't unconfigure EP0
 00FA           .done:
 00FA 818D          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_dev_09
                USB_CB_h2d_std_dev_09:
                    LJMP    APP_USB_CB_h2d_std_dev_09
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_d2h_std_ifc_00
                ;
                ;  DESCRIPTION:   Get Interface Status
                ;
                ;****************************************************************
                ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                ;****************************************************************
                ;
                ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h    
                ; bRequest       : GET_STATUS                     = 00h    
                ; wValue         : RESERVED                       = 0000h  
                ; wIndex         : INTERFACE                      = --xxh
                ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h  
                ; 
                ; The GET_INTERFACE_STATUS request returns status for the 
                ; specified interface.
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
 00FC           .LITERAL
 00FC           GetInterfaceStatusTransferDescrTable:
 00FC 00            DB      ((1) - 1)                 ; Number of table entries - 1
 00FD 01            DB  USB_DS_RAM                             ; Data source (USB_DS_*)
 00FE 0002          DW  2                             ; Transfer size
 0100 0000          DW  USB_TransferBuffer                             ; Data source address
 0102 0000          DW  NULL_PTR                             ; Transfer Completion Status Block Address
 0104 DE            DB  0xde                           ; Reserved 
 0105           .ENDLITERAL
                export  USB_CB_d2h_std_ifc_00
 0105           USB_CB_d2h_std_ifc_00:
 0105           
 0105 550000        MOV     [USB_TransferBuffer], 0    ; Zero the transfer buffer
 0108 550100        MOV     [USB_TransferBuffer+1], 0  ; 
 010B           
 010B 550000        MOV     [USB_t2], 0                ; Use the UM temp var--Selector
 010E 50FC          MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
 0110 57FC          MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB
 0112           
 0112 8172          JMP     USB_GetTableEntry_Local_Std
                ELSE
                IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_ifc_00
                USB_CB_d2h_std_ifc_00:
                    LJMP    APP_USB_CB_d2h_std_ifc_00
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_d2h_std_ifc_10
                ;
                ;  DESCRIPTION:   Get Interface
                ;
                ;****************************************************************
                ; STANDARD INTERFACE IN REQUEST: Get_Interface
                ;****************************************************************
                ;
                ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                ; bRequest       : GET_INTERFACE                  = 0Ah    
                ; wValue         : RESERVED                       = 0000h  
                ; wIndex         : INTERFACE                      = xxxxh
                ; wLength        : SIZEOF_GET_INTERFACE           = 0001h  
                ; 
                ; The GET_INTERFACE request returns the selected alternate 
                ; setting for the specified interface. 
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                
                IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
 0114           .LITERAL
 0114           GetInterfaceTransferDescrTable:
 0114 00            DB      ((1) - 1)                 ; Number of table entries - 1
 0115 01            DB  USB_DS_RAM                             ; Data source (USB_DS_*)
 0116 0001          DW  1                             ; Transfer size
 0118 0000          DW  USB_TransferBuffer                             ; Data source address
 011A 0000          DW  NULL_PTR                             ; Transfer Completion Status Block Address
 011C DE            DB  0xde                           ; Reserved 
 011D           .ENDLITERAL
                export  USB_CB_d2h_std_ifc_10
 011D           USB_CB_d2h_std_ifc_10:
 011D 5D54          MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
 011F 3901          CMP     A, 1h                      ; Valid interface number? (UM Parameter: NumInterfaces)
 0121 DEDE          JNC     USB_Not_Supported
 0123           
 0123 5C            MOV     X, A                       ; The interface number is the index into alternates settings table
 0124           
 0124 5200          MOV     A, [X + USB_InterfaceSetting]  ; Save the current interface setting
 0126 5300          MOV     [USB_TransferBuffer], A    ; into the transfer buffer
 0128           
 0128 550000        MOV     [USB_t2], 0                ; Use the UM temp var--Selector
 012B 5014          MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
 012D 5714          MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB
 012F           
 012F 8155          JMP     USB_GetTableEntry_Local_Std
                ELSE
                IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_ifc_10
                USB_CB_d2h_std_ifc_10:
                    LJMP    APP_USB_CB_d2h_std_ifc_10
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_d2h_std_ep_00
                ;
                ;  DESCRIPTION:   Get Endpoint Status
                ;
                ;****************************************************************
                ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                ;****************************************************************
                ;
                ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h    
                ; bRequest       : GET_STATUS                     = 00h    
                ; wValue         : RESERVED                       = 0000h  
                ; wIndex         : ENDPOINT                       = 00xxh
                ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
                ; 
                ; The GET_ENDPOINT_STATUS request returns status for the specified 
                ; endpoint.
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                export  USB_CB_d2h_std_ep_00
 0131           USB_CB_d2h_std_ep_00:
 0131 5D54          MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the endpoint number
 0133 217F          AND     A, ~USB_DIR_IN             ; Strip off the direction bit
 0135 3903          CMP     A, USB_NUM_ENDPOINTS       ; Range check
 0137 DEC8          JNC     USB_Not_Supported
 0139           
 0139 5C            MOV     X, A                       ; The endpoint number is the index
 013A           
 013A 550000        MOV     [USB_t2], 0                ; Use the UM temp var--Selector
 013D           
 013D 550100        MOV     [USB_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
 0140 5200          MOV     A, [X + USB_EndpointStatus]  ; Get the status
 0142 5300          MOV     [USB_TransferBuffer], A    ; Save it in the report
 0144           
 0144 5007          MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
 0146 5707          MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
 0148           
 0148 813C          JMP     USB_GetTableEntry_Local_Std
                ELSE
                IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
                export  USB_CB_d2h_std_ep_00
                USB_CB_d2h_std_ep_00:
                    LJMP    APP_USB_CB_d2h_std_ep_00
                ENDIF
                ENDIF
                
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_ep_01
                ;
                ;  DESCRIPTION:   Clear Endpoint Feature
                ;
                ;****************************************************************
                ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                ; bRequest       : CLEAR_FEATURE                  = 01h    
                ; wValue         : FEATURE_SELECTOR               = --xxh  
                ; wIndex         : ENDPOINT                       = 00xxh
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The CLEAR_ENDPOINT_FEATURE request disables a particular 
                ; feature for an endpoint. 
                ;
                ; The only feature supported for an endpoint is the EP_HALT 
                ; feature.
                ;
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_ep_01
 014A           USB_CB_h2d_std_ep_01:
 014A 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the feature selector
 014C 3900          CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
 014E BEB1          JNZ     USB_Not_Supported
 0150           
 0150 5D54          MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the Endpoint number
 0152 217F          AND     A, ~USB_DIR_IN             ; Strip off the direction bit
 0154 3900          CMP     A, 0                       ; Since we can't halt the Control Endpoint
 0156 A016          JZ      .done
 0158           
 0158 3903          CMP     A, USB_NUM_ENDPOINTS       ; Range check
 015A DEA5          JNC     USB_Not_Supported
 015C           
 015C 5C            MOV     X, A                       ; Endpoint number is the index
 015D 2700FE        AND     [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt
 0160           
 0160 495480        TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
 0163 B006          JNZ     .in
 0165           
 0165 634408        MOV     REG[X + USB_EP0MODE], USB_MODE_NAK_OUT  ; NAK the endpoint
 0168 8004          JMP     .done    
 016A           .in:
 016A 63440C        MOV     REG[X + USB_EP0MODE], USB_MODE_NAK_IN  ; NAK the endpoint
 016D           .done:        
 016D 811A          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_ep_01
                USB_CB_h2d_std_ep_01:
                    LJMP    APP_USB_CB_h2d_std_ep_01
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_CB_h2d_std_ep_03
                ;
                ;  DESCRIPTION:   Set Endpoint Feature
                ;
                ;****************************************************************
                ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                ;****************************************************************
                ;
                ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                ; bRequest       : SET_FEATURE                    = 03h    
                ; wValue         : FEATURE_SELECTOR               = --xxh  
                ; wIndex         : ENDPOINT                       = 00xxh
                ; wLength        : RESERVED                       = 0000h  
                ; 
                ; The SET_ENDPOINT_FEATURE request enables a particular feature
                ; for a specific endpoint. The only feature supported for an 
                ; endpoint is the EP_HALT feature.
                ; 
                ;****************************************************************
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
                IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                export  USB_CB_h2d_std_ep_03
 016F           USB_CB_h2d_std_ep_03:
 016F 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the feature selector
 0171 3900          CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
 0173 BE8C          JNZ     USB_Not_Supported
 0175           
 0175 5D54          MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the Endpoint number
 0177 217F          AND     A, ~USB_DIR_IN             ; Strip off the direction bit
 0179 3900          CMP     A, 0                       ; Never halt the Control Endpoint
 017B A016          JZ      .done
 017D           
 017D 3903          CMP     A, USB_NUM_ENDPOINTS       ; Range check
 017F DE80          JNC     USB_Not_Supported
 0181           
 0181 5C            MOV     X, A                       ; Endpoint number is the index
 0182           
 0182 2F0001        OR      [X+USB_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
 0185           
 0185 495480        TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
 0188 B006          JNZ     .in
 018A           
 018A 634489        MOV     REG[X + USB_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
 018D 8004          JMP     .done    
 018F           .in:
 018F 63448D        MOV     REG[X + USB_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
 0192           .done:        
 0192 80F5          JMP     USB_NoDataStageControlTransfer_Local_Std
                ELSE
                IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
                export  USB_CB_h2d_std_ep_03
                USB_CB_h2d_std_ep_03:
                    LJMP    APP_USB_CB_h2d_std_ep_03
                ENDIF
                ENDIF
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: ConfigureEP
                ;
                ;  DESCRIPTION:   Configure an endpoint
                ;
                ;  ARGUMENTS:    A contains the endpoint direction
                ;                X contains the endpoint number
                ;
                ;  RETURNS:
                ;
                ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
 0194           ConfigureEP:
 0194 397F          CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
 0196 B002          JNZ     .enable                    ; Only enable it if it is used
 0198 7F            RET                                ; Quick exit if this endpoint is unused
 0199           
 0199           ; Jump here to enable an endpoint
 0199           .enable:
 0199 08            PUSH    A                          ; Save the endpoint direction
 019A 5B            MOV     A, X                       ; We are using a JACC to dispatch to enable the interrupt
 019B 64            ASL     A                          ;  
 019C E001          JACC    .EP_INT_ENABLE             ;  
 019E           .EP_INT_ENABLE:
 019E 8005          JMP     .EP0IntEnable              ; Enable EP0
 01A0 8008          JMP     .EP1IntEnable              ; Enable EP1
 01A2 800B          JMP     .EP2IntEnable              ; Enable EP2
 01A4           ; Jump here to enable EP0 Interrupts
 01A4           .EP0IntEnable:
 01A4 43E101        or    reg[INT_MSK1], INT_MSK1_USB_EP0               ; enable specified interrupt enable bit
 01A7 8009          JMP     .cont
 01A9           .EP1IntEnable:
 01A9 43E102        or    reg[INT_MSK1], INT_MSK1_USB_EP1               ; enable specified interrupt enable bit
 01AC 8004          JMP     .cont
 01AE           .EP2IntEnable:
 01AE 43E104        or    reg[INT_MSK1], INT_MSK1_USB_EP2               ; enable specified interrupt enable bit
 01B1           ; Jump or flow here to continue configuring the endpoint    
 01B1           .cont:
 01B1           
 01B1 5B            MOV     A, X
 01B2 F000          INDEX   USB_USB_EP_BIT_LOOKUP
 01B4 31FF          XOR     A, FFh
 01B6 2400          AND     [USB_EPDataToggle], A ; Clear the data toggle
 01B8           
 01B8 18            POP     A                          ; Get the endpoint direction back
 01B9 2180          AND     A, USB_DIR_IN              ; Is it an IN endpoint?
 01BB B008          JNZ     .in                        ; Jump on IN
 01BD           ; Flow here for an OUT Endpoint
 01BD 634408        MOV     REG[X+EP0MODE], USB_MODE_NAK_OUT ; NAK the endpoint
 01C0 560000        MOV     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
 01C3 7F            RET
 01C4           ; Jump here for an IN Endpoint
 01C4           .in:
 01C4 63440C        MOV     REG[X+EP0MODE], USB_MODE_NAK_IN ; NAK the endpoint
 01C7 560001        MOV     [X+USB_EndpointAPIStatus], EVENT_PENDING ; For the API
 01CA 7F            RET
 01CB           ;-----------------------------------------------------------------------------
 01CB           ;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
 01CB           ;-----------------------------------------------------------------------------
 01CB           ;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
 01CB           ;
 01CB           ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
 01CB           ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
 01CB           ;
 01CB           ;-----------------------------------------------------------------------------
 01CB           ;
 01CB           ;  ARGUMENTS:
 01CB           ;
 01CB           ;  RETURNS:
 01CB           ;
 01CB           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 01CB           ;
 01CB           ;  THEORY of OPERATION or PROCEDURE:
 01CB           ;
 01CB           ;-----------------------------------------------------------------------------
 01CB           USB_DT_d2h_std_dev:
 01CB           ;-----------------------------------------------------------------------------
 01CB 8E44          jmp     USB_CB_d2h_std_dev_00
 01CD 8E32          jmp     USB_CB_d2h_std_dev_01
 01CF 8E30          jmp     USB_CB_d2h_std_dev_02
 01D1 8E2E          jmp     USB_CB_d2h_std_dev_03
 01D3 8E2C          jmp     USB_CB_d2h_std_dev_04
 01D5 8E2A          jmp     USB_CB_d2h_std_dev_05
 01D7 8E47          jmp     USB_CB_d2h_std_dev_06
 01D9 8E26          jmp     USB_CB_d2h_std_dev_07
 01DB 8EA1          jmp     USB_CB_d2h_std_dev_08
 01DD           
 01DD           USB_DT_d2h_std_dev_End:
 0009           USB_DT_d2h_std_dev_Size: equ (USB_DT_d2h_std_dev_End-USB_DT_d2h_std_dev) / 2
 01DD           USB_DT_d2h_std_dev_Dispatch::
 01DD 5D51          MOV    A, REG[USB_EP0DATA + bRequest]
 01DF 3909          CMP   A,USB_DT_d2h_std_dev_Size
 01E1 D004          JNC   .dispatch_not_supported
 01E3 64            ASL   A
 01E4 EFE6          JACC  USB_DT_d2h_std_dev
 01E6           .dispatch_not_supported:
 01E6 8E19          JMP  USB_Not_Supported    
 01E8           ;-----------------------------------------------------------------------------
 01E8           USB_DT_h2d_std_dev:
 01E8           ;-----------------------------------------------------------------------------
 01E8 8E17          jmp     USB_CB_h2d_std_dev_00
 01EA 8E9B          jmp     USB_CB_h2d_std_dev_01
 01EC 8E13          jmp     USB_CB_h2d_std_dev_02
 01EE 8EA2          jmp     USB_CB_h2d_std_dev_03
 01F0 8E0F          jmp     USB_CB_h2d_std_dev_04
 01F2 8EB3          jmp     USB_CB_h2d_std_dev_05
 01F4 8E0B          jmp     USB_CB_h2d_std_dev_06
 01F6 8E09          jmp     USB_CB_h2d_std_dev_07
 01F8 8E07          jmp     USB_CB_h2d_std_dev_08
 01FA 8EB4          jmp     USB_CB_h2d_std_dev_09
 01FC           
 01FC           USB_DT_h2d_std_dev_End:
 000A           USB_DT_h2d_std_dev_Size: equ (USB_DT_h2d_std_dev_End-USB_DT_h2d_std_dev) / 2
 01FC           USB_DT_h2d_std_dev_Dispatch::
 01FC           
 01FC 5D51          MOV     A, REG[USB_EP0DATA + bRequest]
 01FE 390A          CMP   A,USB_DT_h2d_std_dev_Size
 0200 D004          JNC   .dispatch_not_supported
 0202 64            ASL   A
 0203 EFE4          JACC  USB_DT_h2d_std_dev
 0205           .dispatch_not_supported:
 0205 8DFA          JMP  USB_Not_Supported    
 0207           
 0207           ;-----------------------------------------------------------------------------
 0207           USB_DT_d2h_std_ifc:
 0207           ;-----------------------------------------------------------------------------
 0207 8EFD          jmp     USB_CB_d2h_std_ifc_00
 0209 8DF6          jmp     USB_CB_d2h_std_ifc_01
 020B 8DF4          jmp     USB_CB_d2h_std_ifc_02
 020D 8DF2          jmp     USB_CB_d2h_std_ifc_03
 020F 8DF0          jmp     USB_CB_d2h_std_ifc_04
 0211 8DEE          jmp     USB_CB_d2h_std_ifc_05
 0213 8DEC          jmp     USB_CB_d2h_std_ifc_06
 0215 8DEA          jmp     USB_CB_d2h_std_ifc_07
 0217 8DE8          jmp     USB_CB_d2h_std_ifc_08
 0219 8DE6          jmp     USB_CB_d2h_std_ifc_09
 021B 8F01          jmp     USB_CB_d2h_std_ifc_10
 021D           USB_DT_d2h_std_ifc_End:
 000B           USB_DT_d2h_std_ifc_Size: equ (USB_DT_d2h_std_ifc_End-USB_DT_d2h_std_ifc) / 2
 021D           USB_DT_d2h_std_ifc_Dispatch::
 021D 3C0000        CMP     [USB_Configuration], 0     ; Is the device configured?
 0220 B003          JNZ     .configured                ; Jump on configured
 0222 8DDD          JMP    _USB_Not_Supported          ; Stall the request if not configured
 0224           ; Jump here if the device is configured
 0224           .configured:
 0224 5D51          MOV     A, REG[USB_EP0DATA + bRequest]
 0226 390B          CMP   A,USB_DT_d2h_std_ifc_Size
 0228 D004          JNC   .dispatch_not_supported
 022A 64            ASL   A
 022B EFDB          JACC  USB_DT_d2h_std_ifc
 022D           .dispatch_not_supported:
 022D 8DD2          JMP  USB_Not_Supported    
 022F           
 022F           ;-----------------------------------------------------------------------------
 022F           USB_DT_h2d_std_ifc:
 022F           ;-----------------------------------------------------------------------------
 022F 8DD0          jmp     USB_CB_h2d_std_ifc_00
 0231           
 0231           USB_DT_h2d_std_ifc_End:
 0001           USB_DT_h2d_std_ifc_Size: equ (USB_DT_h2d_std_ifc_End-USB_DT_h2d_std_ifc) / 2
 0231           USB_DT_h2d_std_ifc_Dispatch::
 0231 3C0000        CMP     [USB_Configuration], 0     ; Is the device configured?
 0234 B003          JNZ     .configured                ; Jump on configured
 0236 8DC9          JMP    _USB_Not_Supported          ; Stall the request if not configured
 0238           ; Jump here if the device is configured
 0238           .configured:
 0238 5D51          MOV     A, REG[USB_EP0DATA + bRequest]
 023A 3901          CMP   A,USB_DT_h2d_std_ifc_Size
 023C D004          JNC   .dispatch_not_supported
 023E 64            ASL   A
 023F EFEF          JACC  USB_DT_h2d_std_ifc
 0241           .dispatch_not_supported:
 0241 8DBE          JMP  USB_Not_Supported    
 0243           
 0243           ;-----------------------------------------------------------------------------
 0243           USB_DT_d2h_std_ep:
 0243           ;-----------------------------------------------------------------------------
 0243 8EED          jmp     USB_CB_d2h_std_ep_00
 0245           
 0245           USB_DT_d2h_std_ep_End:
 0001           USB_DT_d2h_std_ep_Size: equ (USB_DT_d2h_std_ep_End-USB_DT_d2h_std_ep) / 2
 0245           USB_DT_d2h_std_ep_Dispatch::
 0245 3C0000        CMP     [USB_Configuration], 0     ; Is the device configured?
 0248 B00D          JNZ     .configured                ; Jump on configured
 024A           
 024A 5D55          MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
 024C 5300          MOV     [USB_t2], A                ; Use the UM temp var--Selector
 024E 5D54          MOV     A, REG[USB_EP0DATA + wIndexLo] ;
 0250 2C00          OR      [USB_t2], A                ; Use the UM temp var--Selector
 0252 A003          JZ      .ep0_request
 0254           
 0254 8DAB          JMP    _USB_Not_Supported          ; Stall the request if not configured
 0256           ; Jump here if the device is configured or EP0 request
 0256           .configured:
 0256           .ep0_request:
 0256 5D51          MOV     A, REG[USB_EP0DATA + bRequest]
 0258 3901          CMP   A,USB_DT_d2h_std_ep_Size
 025A D004          JNC   .dispatch_not_supported
 025C 64            ASL   A
 025D EFE5          JACC  USB_DT_d2h_std_ep
 025F           .dispatch_not_supported:
 025F 8DA0          JMP  USB_Not_Supported    
 0261           
 0261           ;-----------------------------------------------------------------------------
 0261           USB_DT_h2d_std_ep:
 0261           ;-----------------------------------------------------------------------------
 0261 8D9E          jmp     USB_CB_h2d_std_ep_00
 0263 8EE6          jmp     USB_CB_h2d_std_ep_01
 0265 8D9A          jmp     USB_CB_h2d_std_ep_02
 0267 8F07          jmp     USB_CB_h2d_std_ep_03
 0269           
 0269           USB_DT_h2d_std_ep_End:
 0004           USB_DT_h2d_std_ep_Size: equ (USB_DT_h2d_std_ep_End-USB_DT_h2d_std_ep) / 2
 0269           USB_DT_h2d_std_ep_Dispatch::
 0269 3C0000        CMP     [USB_Configuration], 0     ; Is the device configured?
 026C B00D          JNZ     .configured                ; Jump on configured
 026E           
 026E 5D55          MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
 0270 5300          MOV     [USB_t2], A                ; Use the UM temp var--Selector
 0272 5D54          MOV     A, REG[USB_EP0DATA + wIndexLo] ;
 0274 2C00          OR      [USB_t2], A                ; Use the UM temp var--Selector
 0276 A003          JZ      .ep0_request
 0278           
 0278 8D87          JMP    _USB_Not_Supported          ; Stall the request if not configured
 027A           ; Jump here if the device is configured or EP0 request
 027A           .configured:
 027A           .ep0_request:
 027A 5D51          MOV     A, REG[USB_EP0DATA + bRequest]
 027C 3904          CMP   A,USB_DT_h2d_std_ep_Size
 027E D004          JNC   .dispatch_not_supported
 0280 64            ASL   A
 0281 EFDF          JACC  USB_DT_h2d_std_ep
 0283           .dispatch_not_supported:
 0283 8D7C          JMP  USB_Not_Supported    
 0285           
 0285           USB_GetTableEntry_Local_Std:
 0285 7D0000        LJMP    USB_GetTableEntry
 0288           
 0288           USB_NoDataStageControlTransfer_Local_Std:
 0288 7D0000        LJMP    USB_NoDataStageControlTransfer
 028B           
 028B           ;-----------------------------------------------
 028B           ; Add custom application code for routines 
 028B           ; redefined by USB_APP_SUPPLIED in USB_HID.INC
 028B           ;-----------------------------------------------
 028B           
 028B              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 028B              ;---------------------------------------------------
 028B              ; Insert your custom code below this banner
 028B              ;---------------------------------------------------
 028B           
 028B              ;---------------------------------------------------
 028B              ; Insert your custom code above this banner
 028B              ;---------------------------------------------------
 028B              ;@PSoC_UserCode_END@ (Do not change this line.)
 028B           
 028B           ; End of File USB_std.asm
